<base href="/">
<title>Test Performance</title>
<script>document.querySelector('base').href = location.pathname.startsWith('/element') ? '/element/performance/' : '/performance/';</script>

<h1>Test Performance</h1>

<x-c>

    <strong>Is Span:</strong> <span is="x-span" x-text="obj.text"></span><br />
    <strong>Is Input:</strong> <input is="x-input" x-value="(obj.text = this.value) && console.log(this, obj.text)" /><br>

    <x-t>obj.text</x-t><br>
    <x-t>obj.text.toUpperCase()</x-t><br>
    <x-i>(obj.text = this.value ?? obj.text).toLowerCase()</x-i></br>

</x-c>

<script type="module">

    // const i = document.createElement('input');
    // const t = document.createElement('template');
    // t.appendChild(i);
    // document.head.appendChild(t);
    // const inputComputedStyle = window.getComputedStyle(i);
    // const style = document.createElement('style');
    // let styleContent = '';
    // Array.from(inputComputedStyle).forEach(key => styleContent += `${key}: ${inputComputedStyle.getPropertyValue(key)} ${inputComputedStyle.getPropertyPriority(key)};`);
    // style.type = 'text/css';
    // style.innerHTML = `x-i { ${styleContent} }`;
    // document.head.appendChild(style);

    const proxies = new Map();
    const handlers = new Map();

    const change = async function ([references, reference, element]) {
        // console.log(element)
        const nodes = references.get(reference) ?? references.set(reference, new Set()).get(reference);
        console.log(nodes);

        let iterator = nodes.values();
        let result = iterator.next();

        while (!result.done) {
            // if (element !== result.value) Promise.resolve(result.value).then(async element => element.render());
            Promise.resolve(result.value).then(async value => value?.render());
            result = iterator.next();
        }

    }

    const set = function (element, references, reference, target, key, value, receiver) {
        if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);
        console.log('set:', reference, key, value, element);

        const from = Reflect.get(target, key, receiver);

        if (from === value) return true;
        if (Number.isNaN(from) && Number.isNaN(value)) return true;

        Reflect.set(target, key, value, receiver);

        reference = reference ? `${reference}.${key}` : key;
        if (references.has(reference)) references.get(reference).add(element);
        else references.set(reference, new Set([element]));
        // proxies?.get?.(element)?.remove?.(reference);

        Promise.resolve([references, reference, element]).then(change);

        return true
    };

    const get = function (element, references, reference, target, key, receiver) {
        if (typeof key === 'symbol') return Reflect.get(target, key, receiver);
        // console.log('get:', reference, key, element);

        reference = reference ? `${reference}.${key}` : key;
        if (references.has(reference)) references.get(reference).add(element);
        else references.set(reference, new Set([element]));

        const value = Reflect.get(target, key, receiver);

        if (value && typeof value === 'object') {
            // if (!proxies.has(element)) proxies.set(element, new Map());
            // let proxy = proxies.get(element).get(reference);
            // if (proxy) return proxy;
            // proxy = new Proxy(value, { get: get.bind(null, element, references, reference), set: set.bind(null, element, references, reference) });
            // proxies.get(element).set(reference, proxy);
            // return proxy;
            return new Proxy(value, { get: get.bind(null, element, references, reference), set: set.bind(null, element, references, reference) });
        }

        return value;
    };

    const context = function (data, element, references, reference) {
        return new Proxy(data, {
            get: get.bind(null, element, references, reference),
            set: set.bind(null, element, references, reference)
        });
    };

    const handler = function (code) {
        code = `with($context){return(${code});}`;
        return handlers.get(code) ?? handlers.set(code, new Function('$context', code)).get(code);
    };

    class XT extends HTMLElement {
        #node;
        #text;
        #context;
        #rendered = false;
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.#node = this.childNodes[0];
        }
        async render(data, references, reference) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.#context = context(data, this, references, reference);
                this.#text = handler(this.#node.textContent);
            }

            this.#node.textContent = await this.#text(this.#context);
        }
    }

    class XI extends HTMLElement {
        #handler;
        #context;
        #rendered = false;
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
                <style>
                    :host {
                        width: 10rem;
                        height: 1.2rem;
                        display: inline-block;
                        border: 1px solid lightgray;
                    }
                </style>
                <slot></slot>
            `;
            this.contentEditable = true;
            this.addEventListener('input', this.input);
        }
        #value = undefined;
        get value() {
            return this.#value;
        }
        set value(value) {
            this.setAttribute('value', this.textContent = this.#value = value);
        }
        async render(data, references, reference) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.#context = context(data, this, references, reference);
                this.#handler = handler(this.textContent);
            }

            this.value = await this.#handler(this.#context);
        }
        async input(event) {
            this.value = this.textContent;
            this.value = await this.#handler(this.#context);
        }
    }

    class XContext extends HTMLElement {
        references = new Map();
        // context = { obj: { text: 'Hello World' } };
        // context = new Proxy({ obj: { text: 'Hello World' } }, { get: get.bind(null, null, this.references, ''), set: set.bind(null, null, this.references, '') });
        context = context({ obj: { text: 'Hello World' } }, null, this.references, '');
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.shadowRoot.firstElementChild.addEventListener('slotchange', this.change.bind(this));
        }
        async each(element) {
            await element.render(this.context, this.references, '');
        }
        async change(event) {
            setTimeout(() => {
                Promise.all(Array.prototype.map.call(this.querySelectorAll('x-i, x-t, [is^="x-"]'), this.each.bind(this)));
            }, 1000)
        }
    }

    class XSpan extends HTMLSpanElement {
        // #html;
        #text;
        #context;
        #rendered = false;
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = '<slot></slot>';
        }
        async render(data, references, reference) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.#context = context(data, this, references, reference);
                const text = this.attributes['x-text'];
                if (text) this.#text = handler(text.value);
                // const html = this.attributes['x-html'];
                // if (html) this.#html = handler(html.value);
            }

            if (this.#text) this.textContent = this.#text(this.#context);
            // if (this.#html) this.innerHTML = this.#html(this.#context);
        }
    }

    class XInput extends HTMLInputElement {
        #value;
        #context;
        #rendered = false;
        constructor() {
            super();
            // this.attachShadow({ mode: 'open' });
            // this.shadowRoot.innerHTML = '<slot></slot>';
        }
        async render(data, references, reference) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.#context = context(data, this, references, reference);
                const value = this.attributes['x-value'];
                if (value) {
                    this.#value = handler(value.value);
                    this.addEventListener('input', async (event) => {
                        console.log(event)
                        // // this.onbeforeinput = async (event) => {
                        // const { data, target } = event;
                        // const { value, selectionStart, selectionEnd } = target;
                        // const next = value.substring(0, selectionStart) + (data ?? '') + value.substring(selectionEnd);

                        // event.preventDefault();
                        // console.log('value before:', this.value, 'next:', next);
                        // this.value = next;
                        // this.value =
                        console.log('value before:', this.value);
                        this.#value.call(this, this.#context);
                        console.log(this.#value)
                        console.log('value after:', this.value);
                        // console.log('value after:', this.value, 'next:', next);
                    });
                }

            }

            // if (this.#value) this.value = await this.#value(this.#context);
        }
    }

    customElements.define('x-t', XT);
    customElements.define('x-i', XI);
    customElements.define('x-span', XSpan, { extends: 'span' });
    customElements.define('x-input', XInput, { extends: 'input' });
    customElements.define('x-c', XContext);

</script>