<base href="/">
<title>Test Performance</title>
<script>document.querySelector('base').href = location.pathname.startsWith('/element') ? '/element/performance/' : '/performance/';</script>

<h1>Test Performance</h1>

<x-c>

    <x-t>obj.text</x-t>
    <br>
    <x-t>obj.text?.toUpperCase()</x-t>
    <br>
    <x-i>(obj.text = this.value ?? obj.text).toLowerCase()</x-i>

</x-c>

<script type="module">

    const X = Symbol.for('x');
    const HANDLERS = new Map();

    const set = function (element, references, path, target, key, to, receiver) {
        // if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);

        const from = Reflect.get(target, key, receiver);
        console.log('set:', path, key, element, from, to);

        if (from === to) return true;
        if (Number.isNaN(from) && Number.isNaN(to)) return true;

        Reflect.set(target, key, to, receiver);

        path = path ? `${path}.${key}` : key;

        const nodes = references.get(path) ?? references.set(path, new Set()).get(path);
        let iterator = nodes.values();
        let result = iterator.next();
        while (!result.done) {
            Promise.resolve(result.value).then(async element => element.render());
            result = iterator.next();
        }

        return true
    };

    const get = function (element, references, path, target, key, receiver) {
        console.log('get:', path, key, element);

        if (key === X) return path ? references.get(path) : references;

        path = path ? `${path}.${key}` : key;

        if (element) {
            if (references.has(path)) references.get(path).add(element);
            else references.set(path, new Set([element]));
        }

        const value = Reflect.get(target, key, receiver);

        if (typeof value === 'object') {
            return new Proxy(value, {
                get: get.bind(null, element, references, path),
                set: set.bind(null, element, references, path),
            });
        }

        return value;
    };

    class XBase extends HTMLElement {
        static handlers = new Map();

        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
        }

        context(context, references) {
            return new Proxy(context, {
                get: get.bind(null, this, references, ''),
                set: set.bind(null, this, references, '')
            });
        }

        handler(code) {
            code = `with($context){return(${code});}`;
            return this.constructor.handlers.get(code) ?? this.constructor.handlers.set(code, new Function('$context', code)).get(code);
        }

    }

    class XText extends XBase {
        #node;
        #rendered = false;
        constructor() {
            super();
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.#node = this.childNodes[0];
        }
        async render(context, references) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.context = super.context(context, references);
                this.handler = super.handler(this.#node.textContent);
            }

            this.#node.textContent = await this.handler(this.context);
        }
    }

    class XContext extends HTMLElement {
        // context = {};
        references = new Map();
        context = new Proxy({ obj: { text: 'Hello World' } }, { get: get.bind(null, null, this.references, ''), set: set.bind(null, null, this.references, '') });
        #shadow = this.attachShadow({ mode: 'open' });

        constructor() {
            super();
            // Object.assign(this.#context, { obj: { text: 'hello world' } });
            this.#shadow.innerHTML = '<slot></slot>';
            this.#shadow.firstElementChild.addEventListener('slotchange', (event) => this.change(event));
        }
        async change(event) {
            const elements = [
                ...this.querySelectorAll('x-i'),
                ...this.querySelectorAll('x-t')
            ];
            for (const element of elements) {
                await element.render(this.context, this.references);
                // await element.render(this.context, this.references);
            }
        }
    }

    class XInput extends XBase {
        #rendered = false;
        constructor() {
            super();
            this.shadowRoot.innerHTML = `
                <style>
                    :host {
                        height: 1rem;
                        width: 10rem;
                        display: inline-block;
                    }
                </style>
                <slot></slot>
            `;
            this.contentEditable = true;
            this.addEventListener('input', this.input);
        }
        #value = undefined;
        get value() {
            return this.#value;
        }
        set value(value) {
            this.setAttribute('value', this.textContent = this.#value = value);
        }
        async render(context, references) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.context = super.context(context, references);
                this.handler = super.handler(this.textContent);
            }

            this.value = await this.handler(this.context);
        }
        async input(event) {
            this.value = this.textContent;
            this.value = await this.handler(this.context);
        }
    }


    class XS extends HTMLSpanElement {
        constructor() {
            super();
            const shadow = this.attachShadow({ mode: 'open' });
            shadow.textContent = 'Hello World';
        }
    }

    customElements.define('x-t', XText);
    customElements.define('x-i', XInput);
    customElements.define('x-c', XContext);
    customElements.define('x-s', XS, { extends: 'span' });

</script>