<base href="/">
<title>Test Performance</title>
<script>document.querySelector('base').href = location.pathname.startsWith('/element') ? '/element/performance/' : '/performance/';</script>

<h1>Test Performance</h1>

<x-c>

    <x-t>obj.text?.toUpperCase()</x-t>
    <x-i value="obj.text = this.value || obj.text"></x-i>

</x-c>

<script type="module">

    const X = Symbol.for('x');
    const HANDLERS = new Map();

    const setChild = function (element, references, path, target, key, to, receiver) {
        // if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);

        console.log('setChild:', path, key, element);

        const from = Reflect.get(target, key, receiver);

        if (from === to) return true;
        if (Number.isNaN(from) && Number.isNaN(to)) return true;

        path = path ? `${path}.${key}` : key;

        const nodes = references.get(path) ?? references.set(path, new Set()).get(path);
        let iterator = nodes.values();
        let result = iterator.next();
        while (!result.done) {
            Promise.resolve(result.value).then(async element => element.render());
            result = iterator.next();
        }

        return true
    };

    const getChild = function (element, references, path, target, key, receiver) {
        if (key === X) return path ? references.get(path) : references;

        console.log('getChild:', path, key, element);

        path = path ? `${path}.${key}` : key;

        if (element) {
            if (references.has(path)) references.get(path).add(element);
            else references.set(path, new Set([element]));
        }

        const value = Reflect.get(target, key, receiver);

        if (typeof value === 'object') {
            return new Proxy(value, {
                get: getChild.bind(null, element, references, path),
                set: setChild.bind(null, element, references, path),
            });
        }

        return value;
    };

    // const set = function (path, target, key, value, receiver) {
    //     // if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);

    //     console.log('set:', path, key);

    //     Reflect.set(target, key, value, receiver);

    //     path = path ? `${path}.${key}` : key;
    //     const nodes = References.get(path) ?? References.set(path, new Set()).get(path);
    //     let iterator = nodes.values();
    //     let result = iterator.next();
    //     while (!result.done) {
    //         Promise.resolve(result.value).then(async element => element.render());
    //         result = iterator.next();
    //     }

    //     return true
    // };

    // const get = function (path, target, key, receiver) {
    //     if (key === X) return path ? References.get(path) : References;

    //     console.log('get:', path, key);

    //     path = path ? `${path}.${key}` : key;
    //     if (!References.has(path)) References.set(path, new Set());

    //     const value = Reflect.get(target, key, receiver);

    //     if (typeof value === 'object') {
    //         return new Proxy(value, {
    //             get: get.bind(null, path),
    //             set: set.bind(null, path),
    //         });
    //     }

    //     return value;
    // };

    class XBase extends HTMLElement {
        static handlers = new Map();

        #context;
        #handler;
        #references;

        get context() { return this.#context; }
        get handler() { return this.#handler; }
        get references() { return this.#references; }

        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
        }

        render(context, references, code) {
            code = `with($context){return(${code});}`;

            this.#context = new Proxy(context, {
                get: getChild.bind(null, this, references, ''),
                set: setChild.bind(null, this, references, '')
            });

            this.#handler = this.constructor.handlers.get(code) ?? this.constructor.handlers.set(code, new Function('$context', code)).get(code);
        }

    }

    class XText extends XBase {
        #node;
        #rendered = false;
        constructor() {
            super();
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.#node = this.childNodes[0];
        }
        async render(context, references) {

            if (!this.#rendered) {
                this.#rendered = true;
                const code = this.#node.textContent;
                await super.render(context, references, code);
            }

            this.#node.textContent = await this.handler(this.context);
        }
    }

    class XContext extends HTMLElement {
        // context = {};
        references = new Map();
        context = new Proxy({ obj: { text: 'Hello World' } }, { get: getChild.bind(null, null, this.references, ''), set: setChild.bind(null, null, this.references, '') });
        #shadow = this.attachShadow({ mode: 'open' });

        constructor() {
            super();
            // Object.assign(this.#context, { obj: { text: 'hello world' } });
            this.#shadow.innerHTML = '<slot></slot>';
            this.#shadow.firstElementChild.addEventListener('slotchange', (event) => this.change(event));
        }
        async change(event) {
            const elements = [
                ...this.querySelectorAll('x-i'),
                ...this.querySelectorAll('x-t')
            ];
            for (const element of elements) {
                await element.render(this.context, this.references);
                // await element.render(this.context, this.references);
            }
        }
    }

    class XInput extends XBase {
        #rendered = false;
        constructor() {
            super();
            this.shadowRoot.innerHTML = `
                <style>
                    :host {
                        height: 1rem;
                        width: 10rem;
                        display: inline-block;
                    }
                </style>
                <slot></slot>
            `;
            // this.oninput = null;
            this.contentEditable = true;
            this.addEventListener('input', this.beforeinput);
            // this.addEventListener('beforeinput', this.beforeinput);
        }
        #value = '';
        get value() {
            return this.#value;
        }
        set value(value) {
            this.setAttribute('value', this.textContent = this.#value = value);
        }
        async render(context, references) {

            if (!this.#rendered) {
                this.#rendered = true;
                const code = this.attributes['value'].value;
                console.log(code)
                console.log(context, references)
                await super.render(context, references, code);
            }

            this.value = await this.handler(this.context);
        }
        async beforeinput(event) {
            // const { data } = event;
            // const { value, selectionStart, selectionEnd } = event.target;

            // console.log(
            //     selectionStart,
            //     selectionEnd,
            //     value.substring(0, event.target.selectionStart),
            //     value,
            //     data,
            //     value.substring(event.target.selectionEnd),
            // );

            // const next = value.substring(0, selectionStart) + (data ?? '') + value.substring(selectionEnd);
            // console.log(next);
            // console.log(event)
            // this.value = this.value;
            // this.value =
            // this.value =
            // console.log(this.#value, this.textContent);
            this.#value = this.textContent;
            // this.value =
            await this.handler(this.context);
        }
    }


    class XS extends HTMLSpanElement {
        constructor() {
            super();
            const shadow = this.attachShadow({ mode: 'open' });
            shadow.textContent = 'Hello World';
        }
    }

    customElements.define('x-t', XText);
    customElements.define('x-i', XInput);
    customElements.define('x-c', XContext);
    customElements.define('x-s', XS, { extends: 'span' });

</script>