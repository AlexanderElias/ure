{
  "version": 3,
  "sources": ["../src/dash.ts", "../src/poly.ts", "../src/html.ts", "../src/display.ts", "../src/observe.ts", "../src/booleans.ts", "../src/render.ts", "../src/component.ts", "../src/schedule.ts", "../src/define.ts", "../src/router.ts", "../src/index.ts"],
  "sourcesContent": ["export default function dash(data: string): string {\n    return data.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n", "\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n\n    }\n\n    if (nodes?.length) {\n        for (const node of nodes) {\n            element.appendChild(\n                typeof node === 'string' ?\n                (element.ownerDocument as Document).createTextNode(node) :\n                node\n            );\n        }\n    }\n\n};\n\nexport const includes = function (item: string | Array<any>, search: any) {\n    return item.indexOf(search) !== -1;\n};\n\n\nconst policy = 'trustedTypes' in window ? (window as any).trustedTypes.createPolicy('default', { createHTML: (data:string) => data }) : null;\nexport const createHTML = function (data: string) {\n    if (policy) {\n        return policy.createHTML(data);\n    } else {\n        return data;\n    }\n}\n\nexport const hasOwn = function (object:any, key:any) {\n    return Object.prototype.hasOwnProperty.call(object, key);\n}", "import { createHTML } from './poly';\n// import parse from './parse';\n\nexport const HtmlCache = new WeakMap();\nexport const HtmlSymbol = Symbol('html');\n\ntype TemplateExpressionsArray = any[];\n\n// export class H {\n//     strings:TemplateStringsArray;\n//     expressions:TemplateExpressionsArray;\n//     template: HTMLTemplateElement;\n//     constructor(strings: TemplateStringsArray, expressions: TemplateExpressionsArray, template: HTMLTemplateElement) {\n//         this.strings = strings;\n//         this.expressions = expressions;\n//         this.template = template;\n//     }\n// }\n\nexport default function html(strings: TemplateStringsArray, ...expressions: TemplateExpressionsArray) {\n    if (HtmlCache.has(strings)) {\n        const template = HtmlCache.get(strings);\n        // return new H(strings, expressions, template);\n        return { strings, expressions, values:expressions, template, symbol: HtmlSymbol };\n    } else {\n        let data = '';\n\n        const length = strings.length - 1;\n\n        for (let index = 0; index < length; index++) {\n            data += `${strings[index]}{{${index}}}`;\n        }\n\n        data += strings[length];\n\n        const template = document.createElement('template');\n        template.innerHTML = createHTML(data);\n\n        // const template = parse(data);\n\n        HtmlCache.set(strings, template);\n\n        // return new H(strings, expressions, template);\n        return { strings, expressions, values:expressions, template, symbol: HtmlSymbol };\n    }\n}\n", "export default function display(data: any): string {\n    switch (typeof data) {\n        case 'undefined':\n            return '';\n        case 'string':\n            return data;\n        case 'number':\n            return `${data}`;\n        case 'bigint':\n            return `${data}`;\n        case 'boolean':\n            return `${data}`;\n        case 'function':\n            return `${data()}`;\n        case 'symbol':\n            return String(data);\n        case 'object':\n            return JSON.stringify(data);\n        default:\n            throw new Error('display - type not handled');\n    }\n}\n", "export type ObserveValue = any;\nexport type ObserveTarget = any;\nexport type ObserveReceiver = any;\nexport type ObserveMethod = () => void;\nexport type ObserveKey = symbol | string;\nexport type ObserveData = Record<string, any>;\n\nconst ObserveCache = new WeakMap();\nconst ObserveNext = Promise.resolve();\n\nconst ObserveSet = function (method: ObserveMethod, target: ObserveTarget, key: ObserveKey, value: ObserveValue, receiver: ObserveReceiver) {\n    if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);\n\n    const from = Reflect.get(target, key, receiver);\n\n    if (from === value) return true;\n    if (Number.isNaN(from) && Number.isNaN(value)) return true;\n\n    if (from && (from.constructor.name === 'Object' || from.constructor.name === 'Array' || from.constructor.name === 'Function')) {\n        const cache = ObserveCache.get(from);\n        if (cache === value) return true;\n        ObserveCache.delete(from);\n    }\n\n    Reflect.set(target, key, value, receiver);\n\n    ObserveNext.then(method);\n\n    return true;\n};\n\nconst ObserveGet = function (method: ObserveMethod, target: ObserveTarget, key: ObserveKey, receiver: ObserveReceiver): ObserveValue {\n    if (typeof key === 'symbol') return Reflect.get(target, key, receiver);\n\n    const value = Reflect.get(target, key, receiver);\n\n    if (value && (value.constructor.name === 'Object' || value.constructor.name === 'Array')) {\n        const cache = ObserveCache.get(value);\n        if (cache) return cache;\n\n        const proxy = new Proxy(value, {\n            get: ObserveGet.bind(null, method),\n            set: ObserveSet.bind(null, method),\n            deleteProperty: ObserveDelete.bind(null, method),\n        });\n\n        ObserveCache.set(value, proxy);\n        return proxy;\n    }\n\n    if (value && target.constructor.name === 'Object' && (value.constructor.name === 'Function' || value.constructor.name === 'AsyncFunction')) {\n        const cache = ObserveCache.get(value);\n        if (cache) return cache;\n\n        const proxy = new Proxy(value, {\n            apply(t, _, a) {\n                return Reflect.apply(t, receiver, a);\n            },\n        });\n\n        ObserveCache.set(value, proxy);\n        return proxy;\n    }\n\n    return value;\n};\n\nconst ObserveDelete = function (method: ObserveMethod, target: ObserveTarget, key: ObserveKey) {\n    if (typeof key === 'symbol') return Reflect.deleteProperty(target, key);\n\n    const from = Reflect.get(target, key);\n    ObserveCache.delete(from);\n    Reflect.deleteProperty(target, key);\n\n    ObserveNext.then(method);\n\n    return true;\n};\n\nconst Observe = function (data: ObserveData, method: ObserveMethod) {\n    return new Proxy(data, {\n        get: ObserveGet.bind(null, method),\n        set: ObserveSet.bind(null, method),\n        deleteProperty: ObserveDelete.bind(null, method),\n    });\n};\n\nexport default Observe;\n", "const booleans = [\n    'allowfullscreen',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'compact',\n    'controls',\n    'declare',\n    'default',\n    'defaultchecked',\n    'defaultmuted',\n    'defaultselected',\n    'defer',\n    'disabled',\n    'draggable',\n    'enabled',\n    'formnovalidate',\n    'indeterminate',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nohref',\n    'noshade',\n    'hidden',\n    'novalidate',\n    'nowrap',\n    'open',\n    'pauseonexit',\n    'readonly',\n    'required',\n    'reversed',\n    'scoped',\n    'seamless',\n    'selected',\n    'sortable',\n    'spellcheck',\n    'translate',\n    'truespeed',\n    'typemustmatch',\n    'visible',\n];\n\nexport default booleans;\n", "import html from './html';\nimport display from './display';\nimport observe from './observe';\nimport booleans from './booleans';\nimport { HtmlSymbol } from './html';\nimport { includes, replaceChildren } from './poly';\n\ntype Value = any;\ntype OldValue = Value;\ntype NewValue = Value;\ntype Values = Array<Value>;\ntype Actions = Array<(oldValue: OldValue, newValue: NewValue) => void>;\n\nconst links= [ 'src', 'href', 'xlink:href' ];\nconst safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\n// const dangerousPattern = /j\\s*a\\s*v\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*:|d\\s*a\\s*t\\s*a\\s*:\\s*t\\s*e\\s*x\\s*t\\s*\\/\\s*h\\s*t\\s*m\\s*l/i;\nconst dangerousLink = function (data: string) {\n    return typeof data !== 'string' || !safePattern.test(data);\n    // return typeof data !== 'string' || !safePattern.test(data) || dangerousPattern.test(data);\n};\n\nconst RootCache = new WeakMap();\n\nconst ObjectAction = function (start: Text, end: Text, actions: Actions, oldValue: OldValue, newValue: NewValue) {\n    oldValue = oldValue ?? {};\n    newValue = newValue ?? {};\n\n    if (oldValue?.strings !== newValue.strings) {\n        let next;\n        let node = end.previousSibling;\n        while (node !== start) {\n            next = node?.previousSibling as ChildNode;\n            node?.parentNode?.removeChild(node);\n            node = next;\n        }\n\n        // const fragment = document.importNode(newValue.template.content, true);\n        // RenderWalk(fragment, newValue.values, actions);\n\n        const fragment = newValue.template.content.cloneNode(true);\n        RenderWalk(fragment, newValue.values, actions);\n        document.adoptNode(fragment);\n\n        const l = actions.length;\n        for (let i = 0; i < l; i++) {\n            actions[i](oldValue.values?.[i], newValue.values[i]);\n        }\n\n        end.parentNode?.insertBefore(fragment, end);\n    } else {\n        const l = actions.length;\n        for (let i = 0; i < l; i++) {\n            actions[i](oldValue.values?.[i], newValue.values[i]);\n        }\n    }\n};\n\nconst ArrayAction = function (start: Text, end: Text, actions: Actions, oldValue: OldValue, newValue: NewValue) {\n    oldValue = oldValue ?? [];\n    newValue = newValue ?? [];\n\n    const oldLength = oldValue.length;\n    const newLength = newValue.length;\n    const common = Math.min(oldLength, newLength);\n\n    for (let i = 0; i < common; i++) {\n        actions[i](oldValue[i], newValue[i]);\n    }\n\n    if (oldLength < newLength) {\n        const template = document.createElement('template');\n        for (let i = oldLength; i < newLength; i++) {\n            if (newValue[i]?.constructor === Object && newValue[i]?.symbol === HtmlSymbol) {\n                const start = document.createTextNode('');\n                const end = document.createTextNode('');\n                const action = ObjectAction.bind(null, start, end, []);\n                template.content.appendChild(start);\n                template.content.appendChild(end);\n                actions.push(action);\n                action(oldValue[i], newValue[i]);\n            } else {\n                const node = document.createTextNode('');\n                const action = StandardAction.bind(null, node as Text);\n                template.content.appendChild(node);\n                actions.push(action);\n                action(oldValue[i], newValue[i]);\n            }\n        }\n        end.parentNode?.insertBefore(template.content as Node, end);\n    } else if (oldLength > newLength) {\n        for (let i = oldLength-1; i > newLength-1; i--) {\n            if (oldValue[i]?.constructor === Object && oldValue[i]?.symbol === HtmlSymbol) {\n                const { template } = oldValue[i];\n                let removes = template.content.childNodes.length + 2;\n                while (removes--) end.parentNode?.removeChild(end.previousSibling as Node);\n            } else {\n                end.parentNode?.removeChild(end.previousSibling as Node);\n            }\n        }\n        actions.length = newLength;\n    }\n};\n\nconst StandardAction = function (node: Text, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    node.textContent = newValue;\n};\n\nconst AttributeOn = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    if (typeof oldValue === 'function') element.removeEventListener(attribute.name.slice(2), oldValue);\n    if (typeof newValue !== 'function') return console.warn(`XElement - attribute name \"${attribute.name}\" and value \"${newValue}\" not allowed`);\n    element.addEventListener(attribute.name.slice(2), newValue);\n};\n\nconst AttributeBoolean = function (element: Element, attribute: { name: string; value: any }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n\n    const value = newValue ? true : false;\n    if (value) element.setAttribute(attribute.name, '');\n    else element.removeAttribute(attribute.name);\n\n    attribute.value = value;\n    Reflect.set(element, attribute.name, attribute.value);\n};\n\nconst AttributeValue = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    const value = display(newValue);\n    attribute.value = value;\n    Reflect.set(element, attribute.name, attribute.value);\n    element.setAttribute(attribute.name, attribute.value);\n};\n\nconst AttributeLink = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n\n    if (dangerousLink(newValue)) {\n        element.removeAttribute(attribute.name);\n        console.warn(`XElement - attribute name \"${attribute.name}\" and value \"${newValue}\" not allowed`);\n        return;\n    }\n\n    attribute.value = newValue;\n    Reflect.set(element, attribute.name, attribute.value);\n    element.setAttribute(attribute.name, attribute.value);\n};\n\nconst AttributeStandard = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    attribute.value = newValue;\n    Reflect.set(element, attribute.name, attribute.value);\n    element.setAttribute(attribute.name, attribute.value);\n};\n\nconst AttributeName = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    element.removeAttribute(oldValue);\n\n    const name = newValue?.toLowerCase();\n\n    if (name === 'value') {\n        attribute.name = name;\n        AttributeValue(element, attribute, attribute.value, attribute.value);\n    } else if (name.startsWith('on')) {\n        console.warn(`XElement - dynamic attribute name \"${newValue}\" not allowed`);\n    } else if (includes(links, name)) {\n        console.warn(`XElement - dynamic attribute name \"${newValue}\" not allowed`);\n    } else if (includes(booleans, name)) {\n        attribute.name = name;\n        AttributeBoolean(element, attribute, attribute.value, attribute.value);\n    } else {\n        attribute.name = name;\n        AttributeStandard(element, attribute, attribute.value, attribute.value);\n    }\n\n    // if (\n    //     typeof newValue !== 'string' ||\n    //     newValue.startsWith('on') ||\n    //     links.includes(newValue)\n    // ) return console.warn(`XElement - dynamic attribute name \"${newValue}\" not allowed`);\n\n    // attribute.name = newValue;\n    // element.setAttribute(attribute.name, attribute.value);\n};\n\nexport const RenderWalk = function (fragment: DocumentFragment, values: Values, actions: Actions) {\n    const walker = document.createTreeWalker(document, 5, null);\n\n    walker.currentNode = fragment;\n\n    let index = 0;\n    let node: Node | null = fragment.firstChild;\n\n    while ((node = walker.nextNode()) !== null) {\n        if (node.nodeType === Node.TEXT_NODE) {\n\n            const start = node.nodeValue?.indexOf('{{') ?? -1;\n\n            if (start == -1) continue;\n\n            if (start != 0) {\n                (node as Text).splitText(start);\n                node = walker.nextNode() as Node;\n            }\n\n            const end = node.nodeValue?.indexOf('}}') ?? -1;\n\n            if (end == -1) continue;\n\n            if (end + 2 != node.nodeValue?.length) {\n                (node as Text).splitText(end + 2);\n            }\n\n            const newValue = values[index++];\n\n            if (newValue?.constructor === Object && newValue?.symbol === HtmlSymbol) {\n                const start = document.createTextNode('');\n                const end = node;\n                end.nodeValue = '';\n                end.parentNode?.insertBefore(start, end);\n                actions.push(ObjectAction.bind(null, start as Text, end as Text, []));\n            } else if (newValue?.constructor === Array) {\n                const start = document.createTextNode('');\n                const end = node;\n                end.nodeValue = '';\n                end.parentNode?.insertBefore(start, end);\n                actions.push(ArrayAction.bind(null, start as Text, end as Text, []));\n            } else {\n                (node as Text).textContent = '';\n                actions.push(StandardAction.bind(null, node as Text));\n            }\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\n            const names = (node as Element).getAttributeNames();\n            for (const name of names) {\n                const value = (node as Element).getAttribute(name) ?? '';\n                const attribute = { name, value };\n\n                const dynamicName = name.includes('{{') && name.includes('}}');\n                const dynamicValue = value.includes('{{') && value.includes('}}');\n\n                if (dynamicName) {\n                    index++;\n                    (node as Element).removeAttribute(name);\n                    actions.push(\n                        AttributeName.bind(null, node as Element, attribute),\n                    );\n                }\n\n                if (dynamicValue) {\n                    index++;\n                    (node as Element).removeAttribute(name);\n                    if (name === 'value') {\n                        actions.push(\n                            AttributeValue.bind(null, node as Element, attribute),\n                        );\n                    } else if (name.startsWith('on')) {\n                        actions.push(\n                            AttributeOn.bind(null, node as Element, attribute),\n                        );\n                    } else if (includes(links, name)) {\n                        actions.push(\n                            AttributeLink.bind(null, node as Element, attribute),\n                        );\n                    } else if (includes(booleans, name)) {\n                        actions.push(\n                            AttributeBoolean.bind(null, node as Element, attribute),\n                        );\n                    } else {\n                        actions.push(\n                            AttributeStandard.bind(null, node as Element, attribute),\n                        );\n                    }\n                }\n\n                if (!dynamicName && !dynamicValue) {\n                    if (includes(links, name)) {\n                        if (dangerousLink(value)) {\n                            (node as Element).removeAttribute(name);\n                            console.warn(`XElement - attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (name.startsWith('on')) {\n                        (node as Element).removeAttribute(name);\n                        console.warn(`XElement - attribute name \"${name}\" not allowed`);\n                    }\n                }\n\n            }\n        } else {\n            console.warn('node type not handled ', node.nodeType);\n        }\n    }\n};\n\nconst sleep = (time: number) => new Promise((resolve) => setTimeout(resolve, time ?? 0));\n\nconst render = async function (\n        root: Element | ShadowRoot,\n        // context: () => Record<any,any>,\n        // content: (context: Record<any,any>) => any\n        context: any,\n        content: any\n    ) {\n    const instance: any = {};\n\n    const update = async function () {\n        if (instance.busy) return;\n        else instance.busy = true;\n\n        await sleep(50);\n\n        if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n        const { values } = content(html, context);\n\n        const length = instance.actions.length;\n        for (let index = 0; index < length; index++) {\n            instance.actions[index](instance.values[index], values[index]);\n        }\n\n        instance.values = values;\n\n        if (context.upgraded) await context.upgraded()?.catch(console.error);\n\n        instance.busy = false;\n    };\n\n    const cache = RootCache.get(root);\n    if (cache && cache.disconnect) await cache.disconnect()?.catch?.(console.error);\n    if (cache && cache.disconnected) await cache.disconnected()?.catch(console.error);\n\n    context = observe(context(html), update);\n\n    RootCache.set(root, context);\n\n    if (context.connect) await context.connect()?.catch?.(console.error);\n    if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n    const { strings, values, template } = content(html, context);\n\n    instance.busy = false;\n    instance.actions = [];\n    instance.values = values;\n    instance.strings = strings;\n    instance.template = template;\n    // instance.fragment = document.importNode(template.content, true);\n    instance.fragment = template.content.cloneNode(true);\n\n    RenderWalk(instance.fragment, instance.values, instance.actions);\n\n    document.adoptNode(instance.fragment);\n\n    const length = instance.actions.length;\n    for (let index = 0; index < length; index++) {\n        instance.actions[index](undefined, values[index]);\n    }\n\n    if (root.replaceChildren) {\n        root.replaceChildren(instance.fragment);\n    } else {\n        replaceChildren(root, instance.fragment);\n    }\n\n    if (context.upgraded) await context.upgraded()?.catch(console.error);\n    if (context.connected) await context.connected()?.catch(console.error);\n};\n\nexport default render;\n", "// import Context from './context';\nimport Schedule from './schedule';\n// import Patch from './patch';\nimport Dash from './dash';\n// import render from './render';\nimport html from './html';\nimport observe from './observe';\nimport { hasOwn, replaceChildren } from './poly';\nimport { RenderWalk } from './render';\n\ninterface ComponentInstance extends HTMLElement {\n    attributeChangedCallback?:any;\n    disconnectedCallback?:any;\n    connectedCallback?:any;\n    adoptedCallback?:any;\n    template:()=>any;\n}\n\ninterface ComponentConstructor {\n\n    tag?:string;\n    shadow?:boolean;\n    observedProperties?: string[];\n\n    create?: typeof create;\n    define?: typeof define;\n    defined?: typeof defined;\n\n    new (): ComponentInstance;\n}\n\nconst Expressions = new WeakMap();\nconst Actions = new WeakMap();\nconst Busy = new WeakMap();\nconst Fragment = new WeakMap();\nconst Root = new WeakMap();\n\n// const DEFINED = new WeakSet();\n// const CE = window.customElements;\n// Object.defineProperty(window, 'customElements', {\n//     get: () => ({\n//         define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions) {\n//             if (constructor.prototype instanceof Component && !DEFINED.has(constructor)) {\n//                 constructor = new Proxy(constructor, {\n//                     construct(target, args, extender) {\n//                         const instance = Reflect.construct(target, args, extender);\n//                             mount(instance);\n//                         return instance;\n//                     },\n//                 });\n\n//                 DEFINED.add(constructor);\n//             }\n//             CE.define(name, constructor, options);\n//         },\n//         get: CE.get,\n//         whenDefined: CE.whenDefined,\n//     }),\n// });\n\n// static slottedEvent = new Event('slotted');\n// static slottingEvent = new Event('slotting');\n\n// static adoptedEvent = new Event('adopted');\n// static adoptingEvent = new Event('adopting');\n\n// static updatedEvent = new Event('updated');\n// static updatingEvent = new Event('updating');\n\n// static upgradedEvent = new Event('upgraded');\n// static upgradingEvent = new Event('upgrading');\n\n// static connectedEvent = new Event('connected');\n// static connectingEvent = new Event('connecting');\n\n// static attributedEvent = new Event('attributed');\n// static attributingEvent = new Event('attributing');\n\n// static disconnectedEvent = new Event('disconnected');\n// static disconnectingEvent = new Event('disconnecting');\n\n// slotted?: ()=>Promise<void> | void;\n// connecting?: ()=>Promise<void> | void;\n// connected?: ()=>Promise<void> | void;\n// attributed?: (name: string, from: string, to: string)=>Promise<void> | void;\n// adopted?: ()=>Promise<void> | void;\n// disconnected?: ()=>Promise<void> | void;\n\n// async slottedCallback() {\n//     this.dispatchEvent(XElement.slottingEvent);\n//     await this.slotted?.();\n//     this.dispatchEvent(XElement.slottedEvent);\n// }\n\n// async connectedCallback() {\n//     this.dispatchEvent(XElement.connectingEvent);\n//     await this.connecting?.();\n//     this.#render();\n//     // this[MOUNT](this[ROOT], this.#context, this.#template);\n\n//     // const constructor = this.constructor as typeof XElement;\n//     // this[MOUNT](this[ROOT], constructor.context, constructor.template);\n//     await this.connected?.();\n//     this.dispatchEvent(XElement.connectedEvent);\n// }\n\n// async disconnectedCallback() {\n//     this.dispatchEvent(XElement.disconnectingEvent);\n//     await this.disconnected?.();\n//     this.dispatchEvent(XElement.disconnectedEvent);\n// }\n\n// async adoptedCallback() {\n//     this.dispatchEvent(XElement.adoptingEvent);\n//     await this.adopted?.();\n//     this.dispatchEvent(XElement.adoptedEvent);\n// }\n\n// async attributeChangedCallback(name: string, from: string, to: string) {\n//     this.dispatchEvent(XElement.attributingEvent);\n//     await this.attributed?.(name, from, to);\n//     this.dispatchEvent(XElement.attributedEvent);\n// }\n\n\nconst create = function (this:ComponentConstructor) {\n    const tag = this.tag ?? Dash(this.name);\n\n    if (!customElements.get(tag)) {\n        customElements.define(tag, this);\n    }\n\n    const element = document.createElement(tag) as ComponentInstance;\n    mount(element);\n\n    return element;\n};\n\nconst define = function (this:ComponentConstructor) {\n    const tag = this.tag ?? Dash(this.name);\n    if (!customElements.get(tag)) return;\n    customElements.define(tag, this);\n};\n\nconst defined = function (this:ComponentConstructor) {\n    const tag = this.tag ?? Dash(this.name);\n    return customElements.whenDefined(tag);\n};\n\nconst update = async function (self:ComponentInstance) {\n\n    if (Busy.get(self)) return;\n    else Busy.set(self, true);\n\n    // await sleep(50);\n\n    // if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n    const result = self.template();\n    const actions = Actions.get(self) as Array<any>;\n    const oldExpressions = Expressions.get(self) as Array<any>;\n    const newExpressions = result.expressions as Array<any>;\n\n    const length = actions.length ?? 0;\n    for (let index = 0; index < length; index++) {\n        actions[index](oldExpressions[index], newExpressions[index]);\n    }\n\n    oldExpressions.splice(0, -1, ...newExpressions);\n\n    // if (context.upgraded) await context.upgraded()?.catch(console.error);\n\n    Busy.set(self, false);\n};\n\nconst mount = async function (self:ComponentInstance) {\n\n    // if (cache && cache.disconnect) await cache.disconnect()?.catch?.(console.error);\n    // if (cache && cache.disconnected) await cache.disconnected()?.catch(console.error);\n\n    // if (context.connect) await context.connect()?.catch?.(console.error);\n    // if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n    const result = self.template();\n\n    const expressions = result.values;\n    Expressions.set(self, expressions);\n\n    const fragment = result.template.content.cloneNode(true);\n    Fragment.set(self, fragment);\n\n    const actions:any = [];\n    Actions.set(self, actions);\n\n    RenderWalk(fragment, expressions, actions);\n\n    document.adoptNode(fragment);\n\n    const length = actions.length;\n    for (let index = 0; index < length; index++) {\n        actions[index](undefined, expressions[index]);\n    }\n\n    const root = Root.get(self);\n\n    replaceChildren(root, fragment);\n\n    // if (context.upgraded) await context.upgraded()?.catch(console.error);\n    // if (context.connected) await context.connected()?.catch(console.error);\n};\n\nexport default function component (Class:ComponentConstructor):ComponentConstructor {\n    Class.create = create;\n    Class.define = define;\n    Class.defined = defined;\n\n    const tag = Class.tag;\n    const shadow = Class.shadow;\n    const observedProperties = Class.observedProperties;\n    const prototype = Class.prototype;\n\n    class Result extends (Class as any) {\n        constructor() {\n            super();\n\n            const self =  (this as any);\n\n            if (shadow) {\n                Root.set(self, self.shadowRoot ?? self.attachShadow({ mode: 'open' }));\n            } else {\n                Root.set(self, self);\n            }\n\n            const properties = observedProperties ?\n                observedProperties ?? [] :\n                [ ...Object.getOwnPropertyNames(self),\n                    ...Object.getOwnPropertyNames(prototype) ];\n\n            for (const property of properties) {\n\n                if (\n                    'attributeChangedCallback' === property ||\n                    'disconnectedCallback' === property ||\n                    'connectedCallback' === property ||\n                    'adoptedCallback' === property ||\n                    'constructor' === property ||\n                    'template' === property\n                ) continue;\n\n                const descriptor = Object.getOwnPropertyDescriptor(self, property) ?? Object.getOwnPropertyDescriptor(prototype, property);\n\n                if (!descriptor) continue;\n                if (!descriptor.configurable) continue;\n\n                Object.defineProperty(self, `_${property}`, {\n                    ...descriptor,\n                    enumerable: false\n                });\n\n                Object.defineProperty(self, property, {\n                    enumerable: descriptor.enumerable,\n                    configurable: descriptor.configurable,\n                    get() {\n                        return this[ `_${property}` ];\n                    },\n                    set(value) {\n                        this[ `_${property}` ] = value;\n                        update(self);\n                    }\n                });\n\n            }\n\n            if (tag) {\n                customElements.upgrade(self);\n                customElements.whenDefined(tag).then(()=> mount(self));\n            }\n\n        }\n        // async connectedCallback() {\n        //     await customElements.whenDefined(tag as string);\n        //     mount(this as any);\n        //     await super.connectedCallback?.();\n        // }\n    };\n\n    if (tag && !customElements.get(tag)) {\n        customElements.define(tag, Result as ComponentConstructor);\n    }\n\n    return Result as ComponentConstructor;\n}\n\ncomponent(\nclass XTest extends HTMLElement {\n    static tag = 'x-test';\n    // static shadow = true;\n    // static observedProperties = ['message'];\n\n    message = 'hello world';\n\n    template = () => html`\n        <h1>${this.message}</h1>\n        <input value=${this.message} oninput=${(e:any)=>this.message=e.target.value} />\n    `;\n    connectedCallback(){\n        console.log('xtest');\n    }\n}\n);\n\nconst e = document.createElement('x-test');\n\nconsole.log(e.outerHTML)\ndocument.body.append(e);\n", "let busy = false;\n\nconst sleep = () => new Promise((resolve) => setTimeout(resolve, 0));\n\nconst Actions: any = [];\nconst OldValues: any = [];\nconst NewValues: any = [];\n\nexport default async function schedule(actions: any[], oldValues: any[], newValues: any[]) {\n    actions = actions ?? [];\n    oldValues = oldValues ?? [];\n    newValues = newValues ?? [];\n\n    Actions.push(...actions);\n    OldValues.push(...oldValues);\n    NewValues.push(...newValues);\n\n    if (busy) return;\n    busy = true;\n\n    let action;\n    let oldValue;\n    let newValue;\n    let max = performance.now() + 50;\n\n    while (Actions.length > 0) {\n        if (\n            (navigator as any).scheduling?.isInputPending() ||\n            performance.now() >= max\n        ) {\n            await sleep();\n            max = performance.now() + 50;\n            continue;\n        }\n\n        action = Actions.shift();\n        oldValue = OldValues.shift();\n        newValue = NewValues.shift();\n\n        if (oldValue !== newValue) {\n            await action(oldValue, newValue);\n        }\n    }\n\n    busy = false;\n}\n", "export default function define(name: string, constructor: CustomElementConstructor) {\n    customElements.define(name, constructor);\n}\n", "import render from './render';\n\ntype Route = {\n    path?: string;\n\n    render?: any;\n    context?: any;\n    content?: any;\n    construct?: any;\n\n    name?: string;\n    root: Element;\n};\n\nconst alls: Array<Route> = [];\nconst routes: Array<Route> = [];\n\nconst transition = async function (route: Route) {\n    // if (route.cache && route.instance) {\n    //     if (route.instance instanceof Component || route.instance.prototype instanceof Component) {\n    //         route.root.replaceChildren(route.instance);\n    //         await route.instance[$].render();\n    //     } else {\n    //         await route.instance.render();\n    //     }\n    // }\n\n    // if (route.component instanceof Component || route.component.prototype instanceof Component) {\n    //     route.name = route.name ?? Dash(route.component.name);\n\n    //     if (!/^\\w+-\\w+/.test(route.name)) route.name = `x-${route.name}`;\n\n    //     if (!customElements.get(route.name)) customElements.define(route.name, route.component);\n    //     await customElements.whenDefined(route.name);\n\n    //     route.instance = document.createElement(route.name);\n    //     route.root.replaceChildren(route.instance);\n    //     route.instance[$].render();\n\n    // }\n    // if (route.render) {\n    //     route.render();\n    // } else {\n    // route.render = await mount(route.root, route.context, route.content);\n    // }\n    await render(route.root, route.context, route.content);\n};\n\nconst navigate = function (event?: any) {\n    if (event && 'canIntercept' in event && event.canIntercept === false) return;\n    if (event && 'canTransition' in event && event.canTransition === false) return;\n\n    const destination = new URL(event?.destination.url ?? location.href);\n    const base = new URL(document.querySelector('base')?.href ?? location.origin);\n\n    base.hash = '';\n    base.search = '';\n    destination.hash = '';\n    destination.search = '';\n\n    const pathname = destination.href.replace(base.href, '/');\n    const transitions: Array<Route> = [];\n\n    for (const route of routes) {\n        if (route.path !== pathname) continue;\n        if (!route.root) continue;\n\n        // const current = Reflect.get(route.root, 'xRouterCurrent');\n        // if (current === route) continue;\n\n        // const busy = Reflect.get(route.root, 'xRouterBusy');\n        // if (busy) continue;\n\n        // if (Reflect.get(route.root, 'xRouterPath') === route.path) continue;\n\n        // const current = Reflect.get(route.root, 'xRouterCurrent');\n        // if (current) current.instance.childNodes = Array.from(current.root.childNodes);\n\n        // Reflect.set(route.root, 'xRouterBusy', true);\n        Reflect.set(route.root, 'xRouterPath', route.path);\n        transitions.push(route);\n    }\n\n    for (const all of alls) {\n        if (!all.root) continue;\n        let has = false;\n\n        for (const transition of transitions) {\n            if (transition.root === all.root) {\n                has = true;\n                break;\n            }\n        }\n\n        if (has) continue;\n        if (Reflect.get(all.root, 'xRouterPath') === pathname) continue;\n        // if (all.root && Reflect.get(all.root, 'xRouterBusy')) continue;\n        // if (all.root) Reflect.set(all.root, 'xRouterBusy', true);\n\n        transitions.push(all);\n    }\n\n    // if (!transitions.length) return;\n\n    if (event?.intercept) {\n        return event.intercept({ handler: () => transitions.map((route) => transition(route)) });\n    } else if (event?.transitionWhile) {\n        return event.transitionWhile(transitions.map((route) => transition(route)));\n    } else {\n        transitions.map((route) => transition(route));\n    }\n};\n\nconst router = function (path: string, root: Element, context: any, content: any) {\n    if (!path) throw new Error('XElement - router path required');\n    if (!root) throw new Error('XElement - router root required');\n    if (!context) throw new Error('XElement - router context required');\n    if (!content) throw new Error('XElement - router content required');\n\n    if (path === '/*') {\n        for (const all of alls) {\n            if (all.path === path && all.root === root) {\n                throw new Error('XElement - router duplicate path on root');\n            }\n        }\n\n        alls.push({ path, root, context, content });\n    } else {\n        for (const route of routes) {\n            if (route.path === path && route.root === root) {\n                throw new Error('XElement - router duplicate path on root');\n            }\n        }\n\n        routes.push({ path, root, context, content });\n    }\n\n    Reflect.get(window, 'navigation').addEventListener('navigate', navigate);\n};\n\nexport default router;\n", "import Component from './component';\nimport Schedule from './schedule';\n// import Context from './context';\nimport Define from './define';\nimport Router from './router';\nimport Render from './render';\n// import Patch from './patch';\n// import Mount from './mount';\n\nexport { Component };\nexport { Component as component };\n\nexport { Schedule };\nexport { Schedule as schedule };\n\n// export { Context };\n// export { Context as context };\n\nexport { Define };\nexport { Define as define };\n\nexport { Router };\nexport { Router as router };\n\nexport { Render };\nexport { Render as render };\n\n// export { Patch };\n// export { Patch as patch };\n\n// export { Mount };\n// export { Mount as mount };\n\nconst Index = {\n    Component,\n    Schedule,\n    // Context,\n    Define,\n    Router,\n    Render,\n    // Patch,\n    // Mount,\n    component: Component,\n    schedule: Schedule,\n    // context: Context,\n    define: Define,\n    router: Router,\n    render: Render,\n    // patch: Patch,\n    // mount: Mount,\n};\n\nexport default Index;\n"],
  "mappings": ";;;;;;;;AAAe,SAAR,KAAsB,MAAsB;AAC/C,SAAO,KAAK,QAAQ,sBAAsB,OAAO,EAAE,YAAY;AACnE;;;ACDO,IAAM,kBAAkB,SAAU,YAAmD,OAAgC;AAExH,SAAO,QAAQ,WAAW;AACtB,YAAQ,YAAY,QAAQ,SAAS;AAAA,EAEzC;AAEA,MAAI,OAAO,QAAQ;AACf,eAAW,QAAQ,OAAO;AACtB,cAAQ;AAAA,QACJ,OAAO,SAAS,WACf,QAAQ,cAA2B,eAAe,IAAI,IACvD;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAEJ;AAEO,IAAM,WAAW,SAAU,MAA2B,QAAa;AACtE,SAAO,KAAK,QAAQ,MAAM,MAAM;AACpC;AAGA,IAAM,SAAS,kBAAkB,SAAU,OAAe,aAAa,aAAa,WAAW,EAAE,YAAY,CAAC,SAAgB,KAAK,CAAC,IAAI;AACjI,IAAM,aAAa,SAAU,MAAc;AAC9C,MAAI,QAAQ;AACR,WAAO,OAAO,WAAW,IAAI;AAAA,EACjC,OAAO;AACH,WAAO;AAAA,EACX;AACJ;;;AC7BO,IAAM,YAAY,oBAAI,QAAQ;AAC9B,IAAM,aAAa,OAAO,MAAM;AAexB,SAAR,KAAsB,YAAkC,aAAuC;AAClG,MAAI,UAAU,IAAI,OAAO,GAAG;AACxB,UAAM,WAAW,UAAU,IAAI,OAAO;AAEtC,WAAO,EAAE,SAAS,aAAa,QAAO,aAAa,UAAU,QAAQ,WAAW;AAAA,EACpF,OAAO;AACH,QAAI,OAAO;AAEX,UAAM,SAAS,QAAQ,SAAS;AAEhC,aAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AACzC,cAAQ,GAAG,QAAQ,KAAK,MAAM;AAAA,IAClC;AAEA,YAAQ,QAAQ,MAAM;AAEtB,UAAM,WAAW,SAAS,cAAc,UAAU;AAClD,aAAS,YAAY,WAAW,IAAI;AAIpC,cAAU,IAAI,SAAS,QAAQ;AAG/B,WAAO,EAAE,SAAS,aAAa,QAAO,aAAa,UAAU,QAAQ,WAAW;AAAA,EACpF;AACJ;;;AC7Ce,SAAR,QAAyB,MAAmB;AAC/C,UAAQ,OAAO,MAAM;AAAA,IACjB,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO;AAAA,IACX,KAAK;AACD,aAAO,GAAG;AAAA,IACd,KAAK;AACD,aAAO,GAAG;AAAA,IACd,KAAK;AACD,aAAO,GAAG;AAAA,IACd,KAAK;AACD,aAAO,GAAG,KAAK;AAAA,IACnB,KAAK;AACD,aAAO,OAAO,IAAI;AAAA,IACtB,KAAK;AACD,aAAO,KAAK,UAAU,IAAI;AAAA,IAC9B;AACI,YAAM,IAAI,MAAM,4BAA4B;AAAA,EACpD;AACJ;;;ACdA,IAAM,eAAe,oBAAI,QAAQ;AACjC,IAAM,cAAc,QAAQ,QAAQ;AAEpC,IAAM,aAAa,SAAU,QAAuB,QAAuB,KAAiB,OAAqB,UAA2B;AACxI,MAAI,OAAO,QAAQ;AAAU,WAAO,QAAQ,IAAI,QAAQ,KAAK,OAAO,QAAQ;AAE5E,QAAM,OAAO,QAAQ,IAAI,QAAQ,KAAK,QAAQ;AAE9C,MAAI,SAAS;AAAO,WAAO;AAC3B,MAAI,OAAO,MAAM,IAAI,KAAK,OAAO,MAAM,KAAK;AAAG,WAAO;AAEtD,MAAI,SAAS,KAAK,YAAY,SAAS,YAAY,KAAK,YAAY,SAAS,WAAW,KAAK,YAAY,SAAS,aAAa;AAC3H,UAAM,QAAQ,aAAa,IAAI,IAAI;AACnC,QAAI,UAAU;AAAO,aAAO;AAC5B,iBAAa,OAAO,IAAI;AAAA,EAC5B;AAEA,UAAQ,IAAI,QAAQ,KAAK,OAAO,QAAQ;AAExC,cAAY,KAAK,MAAM;AAEvB,SAAO;AACX;AAEA,IAAM,aAAa,SAAU,QAAuB,QAAuB,KAAiB,UAAyC;AACjI,MAAI,OAAO,QAAQ;AAAU,WAAO,QAAQ,IAAI,QAAQ,KAAK,QAAQ;AAErE,QAAM,QAAQ,QAAQ,IAAI,QAAQ,KAAK,QAAQ;AAE/C,MAAI,UAAU,MAAM,YAAY,SAAS,YAAY,MAAM,YAAY,SAAS,UAAU;AACtF,UAAM,QAAQ,aAAa,IAAI,KAAK;AACpC,QAAI;AAAO,aAAO;AAElB,UAAM,QAAQ,IAAI,MAAM,OAAO;AAAA,MAC3B,KAAK,WAAW,KAAK,MAAM,MAAM;AAAA,MACjC,KAAK,WAAW,KAAK,MAAM,MAAM;AAAA,MACjC,gBAAgB,cAAc,KAAK,MAAM,MAAM;AAAA,IACnD,CAAC;AAED,iBAAa,IAAI,OAAO,KAAK;AAC7B,WAAO;AAAA,EACX;AAEA,MAAI,SAAS,OAAO,YAAY,SAAS,aAAa,MAAM,YAAY,SAAS,cAAc,MAAM,YAAY,SAAS,kBAAkB;AACxI,UAAM,QAAQ,aAAa,IAAI,KAAK;AACpC,QAAI;AAAO,aAAO;AAElB,UAAM,QAAQ,IAAI,MAAM,OAAO;AAAA,MAC3B,MAAM,GAAG,GAAG,GAAG;AACX,eAAO,QAAQ,MAAM,GAAG,UAAU,CAAC;AAAA,MACvC;AAAA,IACJ,CAAC;AAED,iBAAa,IAAI,OAAO,KAAK;AAC7B,WAAO;AAAA,EACX;AAEA,SAAO;AACX;AAEA,IAAM,gBAAgB,SAAU,QAAuB,QAAuB,KAAiB;AAC3F,MAAI,OAAO,QAAQ;AAAU,WAAO,QAAQ,eAAe,QAAQ,GAAG;AAEtE,QAAM,OAAO,QAAQ,IAAI,QAAQ,GAAG;AACpC,eAAa,OAAO,IAAI;AACxB,UAAQ,eAAe,QAAQ,GAAG;AAElC,cAAY,KAAK,MAAM;AAEvB,SAAO;AACX;AAEA,IAAM,UAAU,SAAU,MAAmB,QAAuB;AAChE,SAAO,IAAI,MAAM,MAAM;AAAA,IACnB,KAAK,WAAW,KAAK,MAAM,MAAM;AAAA,IACjC,KAAK,WAAW,KAAK,MAAM,MAAM;AAAA,IACjC,gBAAgB,cAAc,KAAK,MAAM,MAAM;AAAA,EACnD,CAAC;AACL;AAEA,IAAO,kBAAQ;;;ACvFf,IAAM,WAAW;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAEA,IAAO,mBAAQ;;;ACjCf,IAAM,QAAO,CAAE,OAAO,QAAQ,YAAa;AAC3C,IAAM,cAAc;AAEpB,IAAM,gBAAgB,SAAU,MAAc;AAC1C,SAAO,OAAO,SAAS,YAAY,CAAC,YAAY,KAAK,IAAI;AAE7D;AAEA,IAAM,YAAY,oBAAI,QAAQ;AAE9B,IAAM,eAAe,SAAU,OAAa,KAAW,SAAkB,UAAoB,UAAoB;AAC7G,aAAW,YAAY,CAAC;AACxB,aAAW,YAAY,CAAC;AAExB,MAAI,UAAU,YAAY,SAAS,SAAS;AACxC,QAAI;AACJ,QAAI,OAAO,IAAI;AACf,WAAO,SAAS,OAAO;AACnB,aAAO,MAAM;AACb,YAAM,YAAY,YAAY,IAAI;AAClC,aAAO;AAAA,IACX;AAKA,UAAM,WAAW,SAAS,SAAS,QAAQ,UAAU,IAAI;AACzD,eAAW,UAAU,SAAS,QAAQ,OAAO;AAC7C,aAAS,UAAU,QAAQ;AAE3B,UAAM,IAAI,QAAQ;AAClB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,cAAQ,CAAC,EAAE,SAAS,SAAS,CAAC,GAAG,SAAS,OAAO,CAAC,CAAC;AAAA,IACvD;AAEA,QAAI,YAAY,aAAa,UAAU,GAAG;AAAA,EAC9C,OAAO;AACH,UAAM,IAAI,QAAQ;AAClB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,cAAQ,CAAC,EAAE,SAAS,SAAS,CAAC,GAAG,SAAS,OAAO,CAAC,CAAC;AAAA,IACvD;AAAA,EACJ;AACJ;AAEA,IAAM,cAAc,SAAU,OAAa,KAAW,SAAkB,UAAoB,UAAoB;AAC5G,aAAW,YAAY,CAAC;AACxB,aAAW,YAAY,CAAC;AAExB,QAAM,YAAY,SAAS;AAC3B,QAAM,YAAY,SAAS;AAC3B,QAAM,SAAS,KAAK,IAAI,WAAW,SAAS;AAE5C,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC7B,YAAQ,CAAC,EAAE,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA,EACvC;AAEA,MAAI,YAAY,WAAW;AACvB,UAAM,WAAW,SAAS,cAAc,UAAU;AAClD,aAAS,IAAI,WAAW,IAAI,WAAW,KAAK;AACxC,UAAI,SAAS,CAAC,GAAG,gBAAgB,UAAU,SAAS,CAAC,GAAG,WAAW,YAAY;AAC3E,cAAMA,SAAQ,SAAS,eAAe,EAAE;AACxC,cAAMC,OAAM,SAAS,eAAe,EAAE;AACtC,cAAM,SAAS,aAAa,KAAK,MAAMD,QAAOC,MAAK,CAAC,CAAC;AACrD,iBAAS,QAAQ,YAAYD,MAAK;AAClC,iBAAS,QAAQ,YAAYC,IAAG;AAChC,gBAAQ,KAAK,MAAM;AACnB,eAAO,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA,MACnC,OAAO;AACH,cAAM,OAAO,SAAS,eAAe,EAAE;AACvC,cAAM,SAAS,eAAe,KAAK,MAAM,IAAY;AACrD,iBAAS,QAAQ,YAAY,IAAI;AACjC,gBAAQ,KAAK,MAAM;AACnB,eAAO,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA,MACnC;AAAA,IACJ;AACA,QAAI,YAAY,aAAa,SAAS,SAAiB,GAAG;AAAA,EAC9D,WAAW,YAAY,WAAW;AAC9B,aAAS,IAAI,YAAU,GAAG,IAAI,YAAU,GAAG,KAAK;AAC5C,UAAI,SAAS,CAAC,GAAG,gBAAgB,UAAU,SAAS,CAAC,GAAG,WAAW,YAAY;AAC3E,cAAM,EAAE,SAAS,IAAI,SAAS,CAAC;AAC/B,YAAI,UAAU,SAAS,QAAQ,WAAW,SAAS;AACnD,eAAO;AAAW,cAAI,YAAY,YAAY,IAAI,eAAuB;AAAA,MAC7E,OAAO;AACH,YAAI,YAAY,YAAY,IAAI,eAAuB;AAAA,MAC3D;AAAA,IACJ;AACA,YAAQ,SAAS;AAAA,EACrB;AACJ;AAEA,IAAM,iBAAiB,SAAU,MAAY,UAAoB,UAAoB;AACjF,MAAI,aAAa;AAAU;AAC3B,OAAK,cAAc;AACvB;AAEA,IAAM,cAAc,SAAU,SAAkB,WAA4C,UAAoB,UAAoB;AAChI,MAAI,aAAa;AAAU;AAC3B,MAAI,OAAO,aAAa;AAAY,YAAQ,oBAAoB,UAAU,KAAK,MAAM,CAAC,GAAG,QAAQ;AACjG,MAAI,OAAO,aAAa;AAAY,WAAO,QAAQ,KAAK,8BAA8B,UAAU,oBAAoB,uBAAuB;AAC3I,UAAQ,iBAAiB,UAAU,KAAK,MAAM,CAAC,GAAG,QAAQ;AAC9D;AAEA,IAAM,mBAAmB,SAAU,SAAkB,WAAyC,UAAoB,UAAoB;AAClI,MAAI,aAAa;AAAU;AAE3B,QAAM,QAAQ,WAAW,OAAO;AAChC,MAAI;AAAO,YAAQ,aAAa,UAAU,MAAM,EAAE;AAAA;AAC7C,YAAQ,gBAAgB,UAAU,IAAI;AAE3C,YAAU,QAAQ;AAClB,UAAQ,IAAI,SAAS,UAAU,MAAM,UAAU,KAAK;AACxD;AAEA,IAAM,iBAAiB,SAAU,SAAkB,WAA4C,UAAoB,UAAoB;AACnI,MAAI,aAAa;AAAU;AAC3B,QAAM,QAAQ,QAAQ,QAAQ;AAC9B,YAAU,QAAQ;AAClB,UAAQ,IAAI,SAAS,UAAU,MAAM,UAAU,KAAK;AACpD,UAAQ,aAAa,UAAU,MAAM,UAAU,KAAK;AACxD;AAEA,IAAM,gBAAgB,SAAU,SAAkB,WAA4C,UAAoB,UAAoB;AAClI,MAAI,aAAa;AAAU;AAE3B,MAAI,cAAc,QAAQ,GAAG;AACzB,YAAQ,gBAAgB,UAAU,IAAI;AACtC,YAAQ,KAAK,8BAA8B,UAAU,oBAAoB,uBAAuB;AAChG;AAAA,EACJ;AAEA,YAAU,QAAQ;AAClB,UAAQ,IAAI,SAAS,UAAU,MAAM,UAAU,KAAK;AACpD,UAAQ,aAAa,UAAU,MAAM,UAAU,KAAK;AACxD;AAEA,IAAM,oBAAoB,SAAU,SAAkB,WAA4C,UAAoB,UAAoB;AACtI,MAAI,aAAa;AAAU;AAC3B,YAAU,QAAQ;AAClB,UAAQ,IAAI,SAAS,UAAU,MAAM,UAAU,KAAK;AACpD,UAAQ,aAAa,UAAU,MAAM,UAAU,KAAK;AACxD;AAEA,IAAM,gBAAgB,SAAU,SAAkB,WAA4C,UAAoB,UAAoB;AAClI,MAAI,aAAa;AAAU;AAC3B,UAAQ,gBAAgB,QAAQ;AAEhC,QAAM,OAAO,UAAU,YAAY;AAEnC,MAAI,SAAS,SAAS;AAClB,cAAU,OAAO;AACjB,mBAAe,SAAS,WAAW,UAAU,OAAO,UAAU,KAAK;AAAA,EACvE,WAAW,KAAK,WAAW,IAAI,GAAG;AAC9B,YAAQ,KAAK,sCAAsC,uBAAuB;AAAA,EAC9E,WAAW,SAAS,OAAO,IAAI,GAAG;AAC9B,YAAQ,KAAK,sCAAsC,uBAAuB;AAAA,EAC9E,WAAW,SAAS,kBAAU,IAAI,GAAG;AACjC,cAAU,OAAO;AACjB,qBAAiB,SAAS,WAAW,UAAU,OAAO,UAAU,KAAK;AAAA,EACzE,OAAO;AACH,cAAU,OAAO;AACjB,sBAAkB,SAAS,WAAW,UAAU,OAAO,UAAU,KAAK;AAAA,EAC1E;AAUJ;AAEO,IAAM,aAAa,SAAU,UAA4B,QAAgB,SAAkB;AAC9F,QAAM,SAAS,SAAS,iBAAiB,UAAU,GAAG,IAAI;AAE1D,SAAO,cAAc;AAErB,MAAI,QAAQ;AACZ,MAAI,OAAoB,SAAS;AAEjC,UAAQ,OAAO,OAAO,SAAS,OAAO,MAAM;AACxC,QAAI,KAAK,aAAa,KAAK,WAAW;AAElC,YAAM,QAAQ,KAAK,WAAW,QAAQ,IAAI,KAAK;AAE/C,UAAI,SAAS;AAAI;AAEjB,UAAI,SAAS,GAAG;AACZ,QAAC,KAAc,UAAU,KAAK;AAC9B,eAAO,OAAO,SAAS;AAAA,MAC3B;AAEA,YAAM,MAAM,KAAK,WAAW,QAAQ,IAAI,KAAK;AAE7C,UAAI,OAAO;AAAI;AAEf,UAAI,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,QAAC,KAAc,UAAU,MAAM,CAAC;AAAA,MACpC;AAEA,YAAM,WAAW,OAAO,OAAO;AAE/B,UAAI,UAAU,gBAAgB,UAAU,UAAU,WAAW,YAAY;AACrE,cAAMD,SAAQ,SAAS,eAAe,EAAE;AACxC,cAAMC,OAAM;AACZ,QAAAA,KAAI,YAAY;AAChB,QAAAA,KAAI,YAAY,aAAaD,QAAOC,IAAG;AACvC,gBAAQ,KAAK,aAAa,KAAK,MAAMD,QAAeC,MAAa,CAAC,CAAC,CAAC;AAAA,MACxE,WAAW,UAAU,gBAAgB,OAAO;AACxC,cAAMD,SAAQ,SAAS,eAAe,EAAE;AACxC,cAAMC,OAAM;AACZ,QAAAA,KAAI,YAAY;AAChB,QAAAA,KAAI,YAAY,aAAaD,QAAOC,IAAG;AACvC,gBAAQ,KAAK,YAAY,KAAK,MAAMD,QAAeC,MAAa,CAAC,CAAC,CAAC;AAAA,MACvE,OAAO;AACH,QAAC,KAAc,cAAc;AAC7B,gBAAQ,KAAK,eAAe,KAAK,MAAM,IAAY,CAAC;AAAA,MACxD;AAAA,IACJ,WAAW,KAAK,aAAa,KAAK,cAAc;AAC5C,YAAM,QAAS,KAAiB,kBAAkB;AAClD,iBAAW,QAAQ,OAAO;AACtB,cAAM,QAAS,KAAiB,aAAa,IAAI,KAAK;AACtD,cAAM,YAAY,EAAE,MAAM,MAAM;AAEhC,cAAM,cAAc,KAAK,SAAS,IAAI,KAAK,KAAK,SAAS,IAAI;AAC7D,cAAM,eAAe,MAAM,SAAS,IAAI,KAAK,MAAM,SAAS,IAAI;AAEhE,YAAI,aAAa;AACb;AACA,UAAC,KAAiB,gBAAgB,IAAI;AACtC,kBAAQ;AAAA,YACJ,cAAc,KAAK,MAAM,MAAiB,SAAS;AAAA,UACvD;AAAA,QACJ;AAEA,YAAI,cAAc;AACd;AACA,UAAC,KAAiB,gBAAgB,IAAI;AACtC,cAAI,SAAS,SAAS;AAClB,oBAAQ;AAAA,cACJ,eAAe,KAAK,MAAM,MAAiB,SAAS;AAAA,YACxD;AAAA,UACJ,WAAW,KAAK,WAAW,IAAI,GAAG;AAC9B,oBAAQ;AAAA,cACJ,YAAY,KAAK,MAAM,MAAiB,SAAS;AAAA,YACrD;AAAA,UACJ,WAAW,SAAS,OAAO,IAAI,GAAG;AAC9B,oBAAQ;AAAA,cACJ,cAAc,KAAK,MAAM,MAAiB,SAAS;AAAA,YACvD;AAAA,UACJ,WAAW,SAAS,kBAAU,IAAI,GAAG;AACjC,oBAAQ;AAAA,cACJ,iBAAiB,KAAK,MAAM,MAAiB,SAAS;AAAA,YAC1D;AAAA,UACJ,OAAO;AACH,oBAAQ;AAAA,cACJ,kBAAkB,KAAK,MAAM,MAAiB,SAAS;AAAA,YAC3D;AAAA,UACJ;AAAA,QACJ;AAEA,YAAI,CAAC,eAAe,CAAC,cAAc;AAC/B,cAAI,SAAS,OAAO,IAAI,GAAG;AACvB,gBAAI,cAAc,KAAK,GAAG;AACtB,cAAC,KAAiB,gBAAgB,IAAI;AACtC,sBAAQ,KAAK,8BAA8B,oBAAoB,oBAAoB;AAAA,YACvF;AAAA,UACJ,WAAW,KAAK,WAAW,IAAI,GAAG;AAC9B,YAAC,KAAiB,gBAAgB,IAAI;AACtC,oBAAQ,KAAK,8BAA8B,mBAAmB;AAAA,UAClE;AAAA,QACJ;AAAA,MAEJ;AAAA,IACJ,OAAO;AACH,cAAQ,KAAK,0BAA0B,KAAK,QAAQ;AAAA,IACxD;AAAA,EACJ;AACJ;AAEA,IAAM,QAAQ,CAAC,SAAiB,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,QAAQ,CAAC,CAAC;AAEvF,IAAM,SAAS,eACP,MAGA,SACA,SACF;AACF,QAAM,WAAgB,CAAC;AAEvB,QAAMC,UAAS,iBAAkB;AAC7B,QAAI,SAAS;AAAM;AAAA;AACd,eAAS,OAAO;AAErB,UAAM,MAAM,EAAE;AAEd,QAAI,QAAQ;AAAS,YAAM,QAAQ,QAAQ,GAAG,QAAQ,QAAQ,KAAK;AAEnE,UAAM,EAAE,QAAAC,QAAO,IAAI,QAAQ,MAAM,OAAO;AAExC,UAAMC,UAAS,SAAS,QAAQ;AAChC,aAAS,QAAQ,GAAG,QAAQA,SAAQ,SAAS;AACzC,eAAS,QAAQ,KAAK,EAAE,SAAS,OAAO,KAAK,GAAGD,QAAO,KAAK,CAAC;AAAA,IACjE;AAEA,aAAS,SAASA;AAElB,QAAI,QAAQ;AAAU,YAAM,QAAQ,SAAS,GAAG,MAAM,QAAQ,KAAK;AAEnE,aAAS,OAAO;AAAA,EACpB;AAEA,QAAM,QAAQ,UAAU,IAAI,IAAI;AAChC,MAAI,SAAS,MAAM;AAAY,UAAM,MAAM,WAAW,GAAG,QAAQ,QAAQ,KAAK;AAC9E,MAAI,SAAS,MAAM;AAAc,UAAM,MAAM,aAAa,GAAG,MAAM,QAAQ,KAAK;AAEhF,YAAU,gBAAQ,QAAQ,IAAI,GAAGD,OAAM;AAEvC,YAAU,IAAI,MAAM,OAAO;AAE3B,MAAI,QAAQ;AAAS,UAAM,QAAQ,QAAQ,GAAG,QAAQ,QAAQ,KAAK;AACnE,MAAI,QAAQ;AAAS,UAAM,QAAQ,QAAQ,GAAG,QAAQ,QAAQ,KAAK;AAEnE,QAAM,EAAE,SAAS,QAAQ,SAAS,IAAI,QAAQ,MAAM,OAAO;AAE3D,WAAS,OAAO;AAChB,WAAS,UAAU,CAAC;AACpB,WAAS,SAAS;AAClB,WAAS,UAAU;AACnB,WAAS,WAAW;AAEpB,WAAS,WAAW,SAAS,QAAQ,UAAU,IAAI;AAEnD,aAAW,SAAS,UAAU,SAAS,QAAQ,SAAS,OAAO;AAE/D,WAAS,UAAU,SAAS,QAAQ;AAEpC,QAAM,SAAS,SAAS,QAAQ;AAChC,WAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AACzC,aAAS,QAAQ,KAAK,EAAE,QAAW,OAAO,KAAK,CAAC;AAAA,EACpD;AAEA,MAAI,KAAK,iBAAiB;AACtB,SAAK,gBAAgB,SAAS,QAAQ;AAAA,EAC1C,OAAO;AACH,oBAAgB,MAAM,SAAS,QAAQ;AAAA,EAC3C;AAEA,MAAI,QAAQ;AAAU,UAAM,QAAQ,SAAS,GAAG,MAAM,QAAQ,KAAK;AACnE,MAAI,QAAQ;AAAW,UAAM,QAAQ,UAAU,GAAG,MAAM,QAAQ,KAAK;AACzE;AAEA,IAAO,iBAAQ;;;AChVf,IAAM,cAAc,oBAAI,QAAQ;AAChC,IAAM,UAAU,oBAAI,QAAQ;AAC5B,IAAM,OAAO,oBAAI,QAAQ;AACzB,IAAM,WAAW,oBAAI,QAAQ;AAC7B,IAAM,OAAO,oBAAI,QAAQ;AA0FzB,IAAM,SAAS,WAAqC;AAChD,QAAM,MAAM,KAAK,OAAO,KAAK,KAAK,IAAI;AAEtC,MAAI,CAAC,eAAe,IAAI,GAAG,GAAG;AAC1B,mBAAe,OAAO,KAAK,IAAI;AAAA,EACnC;AAEA,QAAM,UAAU,SAAS,cAAc,GAAG;AAC1C,QAAM,OAAO;AAEb,SAAO;AACX;AAEA,IAAM,SAAS,WAAqC;AAChD,QAAM,MAAM,KAAK,OAAO,KAAK,KAAK,IAAI;AACtC,MAAI,CAAC,eAAe,IAAI,GAAG;AAAG;AAC9B,iBAAe,OAAO,KAAK,IAAI;AACnC;AAEA,IAAM,UAAU,WAAqC;AACjD,QAAM,MAAM,KAAK,OAAO,KAAK,KAAK,IAAI;AACtC,SAAO,eAAe,YAAY,GAAG;AACzC;AAEA,IAAM,SAAS,eAAgB,MAAwB;AAEnD,MAAI,KAAK,IAAI,IAAI;AAAG;AAAA;AACf,SAAK,IAAI,MAAM,IAAI;AAMxB,QAAM,SAAS,KAAK,SAAS;AAC7B,QAAM,UAAU,QAAQ,IAAI,IAAI;AAChC,QAAM,iBAAiB,YAAY,IAAI,IAAI;AAC3C,QAAM,iBAAiB,OAAO;AAE9B,QAAM,SAAS,QAAQ,UAAU;AACjC,WAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AACzC,YAAQ,KAAK,EAAE,eAAe,KAAK,GAAG,eAAe,KAAK,CAAC;AAAA,EAC/D;AAEA,iBAAe,OAAO,GAAG,IAAI,GAAG,cAAc;AAI9C,OAAK,IAAI,MAAM,KAAK;AACxB;AAEA,IAAM,QAAQ,eAAgB,MAAwB;AAQlD,QAAM,SAAS,KAAK,SAAS;AAE7B,QAAM,cAAc,OAAO;AAC3B,cAAY,IAAI,MAAM,WAAW;AAEjC,QAAM,WAAW,OAAO,SAAS,QAAQ,UAAU,IAAI;AACvD,WAAS,IAAI,MAAM,QAAQ;AAE3B,QAAM,UAAc,CAAC;AACrB,UAAQ,IAAI,MAAM,OAAO;AAEzB,aAAW,UAAU,aAAa,OAAO;AAEzC,WAAS,UAAU,QAAQ;AAE3B,QAAM,SAAS,QAAQ;AACvB,WAAS,QAAQ,GAAG,QAAQ,QAAQ,SAAS;AACzC,YAAQ,KAAK,EAAE,QAAW,YAAY,KAAK,CAAC;AAAA,EAChD;AAEA,QAAM,OAAO,KAAK,IAAI,IAAI;AAE1B,kBAAgB,MAAM,QAAQ;AAIlC;AAEe,SAAR,UAA4B,OAAiD;AAChF,QAAM,SAAS;AACf,QAAM,SAAS;AACf,QAAM,UAAU;AAEhB,QAAM,MAAM,MAAM;AAClB,QAAM,SAAS,MAAM;AACrB,QAAM,qBAAqB,MAAM;AACjC,QAAM,YAAY,MAAM;AAExB,QAAM,eAAgB,MAAc;AAAA,IAChC,cAAc;AACV,YAAM;AAEN,YAAM,OAAS;AAEf,UAAI,QAAQ;AACR,aAAK,IAAI,MAAM,KAAK,cAAc,KAAK,aAAa,EAAE,MAAM,OAAO,CAAC,CAAC;AAAA,MACzE,OAAO;AACH,aAAK,IAAI,MAAM,IAAI;AAAA,MACvB;AAEA,YAAM,aAAa,qBACf,sBAAsB,CAAC,IACvB;AAAA,QAAE,GAAG,OAAO,oBAAoB,IAAI;AAAA,QAChC,GAAG,OAAO,oBAAoB,SAAS;AAAA,MAAE;AAEjD,iBAAW,YAAY,YAAY;AAE/B,YACI,+BAA+B,YAC/B,2BAA2B,YAC3B,wBAAwB,YACxB,sBAAsB,YACtB,kBAAkB,YAClB,eAAe;AACjB;AAEF,cAAM,aAAa,OAAO,yBAAyB,MAAM,QAAQ,KAAK,OAAO,yBAAyB,WAAW,QAAQ;AAEzH,YAAI,CAAC;AAAY;AACjB,YAAI,CAAC,WAAW;AAAc;AAE9B,eAAO,eAAe,MAAM,IAAI,YAAY;AAAA,UACxC,GAAG;AAAA,UACH,YAAY;AAAA,QAChB,CAAC;AAED,eAAO,eAAe,MAAM,UAAU;AAAA,UAClC,YAAY,WAAW;AAAA,UACvB,cAAc,WAAW;AAAA,UACzB,MAAM;AACF,mBAAO,KAAM,IAAI,UAAW;AAAA,UAChC;AAAA,UACA,IAAI,OAAO;AACP,iBAAM,IAAI,UAAW,IAAI;AACzB,mBAAO,IAAI;AAAA,UACf;AAAA,QACJ,CAAC;AAAA,MAEL;AAEA,UAAI,KAAK;AACL,uBAAe,QAAQ,IAAI;AAC3B,uBAAe,YAAY,GAAG,EAAE,KAAK,MAAK,MAAM,IAAI,CAAC;AAAA,MACzD;AAAA,IAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMJ;AAAC;AAED,MAAI,OAAO,CAAC,eAAe,IAAI,GAAG,GAAG;AACjC,mBAAe,OAAO,KAAK,MAA8B;AAAA,EAC7D;AAEA,SAAO;AACX;AAnSA;AAqSA;AAAA,GACA,mBAAoB,YAAY;AAAA;AAAA;AAAA,IAK5B,UAAU;AAAA,IAEV,WAAW,MAAM;AAAA,cACP,KAAK;AAAA,uBACI,KAAK,mBAAmB,CAACG,OAAQ,KAAK,UAAQA,GAAE,OAAO;AAAA;AAAA,IAE1E,oBAAmB;AACf,cAAQ,IAAI,OAAO;AAAA,IACvB;AAAA,EACJ,GAbI,cADJ,IACW,OAAM,WADjB;AAeA;AAEA,IAAM,IAAI,SAAS,cAAc,QAAQ;AAEzC,QAAQ,IAAI,EAAE,SAAS;AACvB,SAAS,KAAK,OAAO,CAAC;;;AC1TtB,IAAI,OAAO;AAEX,IAAMC,SAAQ,MAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,CAAC,CAAC;AAEnE,IAAMC,WAAe,CAAC;AACtB,IAAM,YAAiB,CAAC;AACxB,IAAM,YAAiB,CAAC;AAExB,eAAO,SAAgC,SAAgB,WAAkB,WAAkB;AACvF,YAAU,WAAW,CAAC;AACtB,cAAY,aAAa,CAAC;AAC1B,cAAY,aAAa,CAAC;AAE1B,EAAAA,SAAQ,KAAK,GAAG,OAAO;AACvB,YAAU,KAAK,GAAG,SAAS;AAC3B,YAAU,KAAK,GAAG,SAAS;AAE3B,MAAI;AAAM;AACV,SAAO;AAEP,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,MAAM,YAAY,IAAI,IAAI;AAE9B,SAAOA,SAAQ,SAAS,GAAG;AACvB,QACK,UAAkB,YAAY,eAAe,KAC9C,YAAY,IAAI,KAAK,KACvB;AACE,YAAMD,OAAM;AACZ,YAAM,YAAY,IAAI,IAAI;AAC1B;AAAA,IACJ;AAEA,aAASC,SAAQ,MAAM;AACvB,eAAW,UAAU,MAAM;AAC3B,eAAW,UAAU,MAAM;AAE3B,QAAI,aAAa,UAAU;AACvB,YAAM,OAAO,UAAU,QAAQ;AAAA,IACnC;AAAA,EACJ;AAEA,SAAO;AACX;;;AC7Ce,SAARC,QAAwB,MAAc,aAAuC;AAChF,iBAAe,OAAO,MAAM,WAAW;AAC3C;;;ACYA,IAAM,OAAqB,CAAC;AAC5B,IAAM,SAAuB,CAAC;AAE9B,IAAM,aAAa,eAAgB,OAAc;AA4B7C,QAAM,eAAO,MAAM,MAAM,MAAM,SAAS,MAAM,OAAO;AACzD;AAEA,IAAM,WAAW,SAAU,OAAa;AACpC,MAAI,SAAS,kBAAkB,SAAS,MAAM,iBAAiB;AAAO;AACtE,MAAI,SAAS,mBAAmB,SAAS,MAAM,kBAAkB;AAAO;AAExE,QAAM,cAAc,IAAI,IAAI,OAAO,YAAY,OAAO,SAAS,IAAI;AACnE,QAAM,OAAO,IAAI,IAAI,SAAS,cAAc,MAAM,GAAG,QAAQ,SAAS,MAAM;AAE5E,OAAK,OAAO;AACZ,OAAK,SAAS;AACd,cAAY,OAAO;AACnB,cAAY,SAAS;AAErB,QAAM,WAAW,YAAY,KAAK,QAAQ,KAAK,MAAM,GAAG;AACxD,QAAM,cAA4B,CAAC;AAEnC,aAAW,SAAS,QAAQ;AACxB,QAAI,MAAM,SAAS;AAAU;AAC7B,QAAI,CAAC,MAAM;AAAM;AAcjB,YAAQ,IAAI,MAAM,MAAM,eAAe,MAAM,IAAI;AACjD,gBAAY,KAAK,KAAK;AAAA,EAC1B;AAEA,aAAW,OAAO,MAAM;AACpB,QAAI,CAAC,IAAI;AAAM;AACf,QAAI,MAAM;AAEV,eAAWC,eAAc,aAAa;AAClC,UAAIA,YAAW,SAAS,IAAI,MAAM;AAC9B,cAAM;AACN;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI;AAAK;AACT,QAAI,QAAQ,IAAI,IAAI,MAAM,aAAa,MAAM;AAAU;AAIvD,gBAAY,KAAK,GAAG;AAAA,EACxB;AAIA,MAAI,OAAO,WAAW;AAClB,WAAO,MAAM,UAAU,EAAE,SAAS,MAAM,YAAY,IAAI,CAAC,UAAU,WAAW,KAAK,CAAC,EAAE,CAAC;AAAA,EAC3F,WAAW,OAAO,iBAAiB;AAC/B,WAAO,MAAM,gBAAgB,YAAY,IAAI,CAAC,UAAU,WAAW,KAAK,CAAC,CAAC;AAAA,EAC9E,OAAO;AACH,gBAAY,IAAI,CAAC,UAAU,WAAW,KAAK,CAAC;AAAA,EAChD;AACJ;AAEA,IAAM,SAAS,SAAU,MAAc,MAAe,SAAc,SAAc;AAC9E,MAAI,CAAC;AAAM,UAAM,IAAI,MAAM,iCAAiC;AAC5D,MAAI,CAAC;AAAM,UAAM,IAAI,MAAM,iCAAiC;AAC5D,MAAI,CAAC;AAAS,UAAM,IAAI,MAAM,oCAAoC;AAClE,MAAI,CAAC;AAAS,UAAM,IAAI,MAAM,oCAAoC;AAElE,MAAI,SAAS,MAAM;AACf,eAAW,OAAO,MAAM;AACpB,UAAI,IAAI,SAAS,QAAQ,IAAI,SAAS,MAAM;AACxC,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC9D;AAAA,IACJ;AAEA,SAAK,KAAK,EAAE,MAAM,MAAM,SAAS,QAAQ,CAAC;AAAA,EAC9C,OAAO;AACH,eAAW,SAAS,QAAQ;AACxB,UAAI,MAAM,SAAS,QAAQ,MAAM,SAAS,MAAM;AAC5C,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC9D;AAAA,IACJ;AAEA,WAAO,KAAK,EAAE,MAAM,MAAM,SAAS,QAAQ,CAAC;AAAA,EAChD;AAEA,UAAQ,IAAI,QAAQ,YAAY,EAAE,iBAAiB,YAAY,QAAQ;AAC3E;AAEA,IAAO,iBAAQ;;;AC3Gf,IAAM,QAAQ;AAAA,EACV;AAAA,EACA;AAAA;AAAA,EAEA,QAAAC;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA;AAAA,EAEA,QAAQA;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA;AAAA;AAGZ;AAEA,IAAO,cAAQ;",
  "names": ["start", "end", "update", "values", "length", "e", "sleep", "Actions", "define", "transition", "define"]
}
