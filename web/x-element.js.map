{
  "version": 3,
  "sources": ["../src/dash.ts", "../src/poly.ts", "../src/html.ts", "../src/display.ts", "../src/observe.ts", "../src/booleans.ts", "../src/render.ts", "../src/component.ts", "../src/schedule.ts", "../src/define.ts", "../src/router.ts", "../src/index.ts"],
  "sourcesContent": ["export default function dash(data: string): string {\n    return data.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n", "\nexport const replaceChildren = function (element: Element | Document | DocumentFragment, ...nodes: (Node | string)[]): void {\n\n    while (element.lastChild) {\n        element.removeChild(element.lastChild);\n\n    }\n\n    if (nodes?.length) {\n        for (const node of nodes) {\n            element.appendChild(\n                typeof node === 'string' ?\n                (element.ownerDocument as Document).createTextNode(node) :\n                node\n            );\n        }\n    }\n\n};\n\nexport const includes = function (item: string | Array<any>, search: any) {\n    return item.indexOf(search) !== -1;\n};\n\n\nconst policy = 'trustedTypes' in window ? (window as any).trustedTypes.createPolicy('default', { createHTML: (data:string) => data }) : null;\nexport const createHTML = function (data: string) {\n    if (policy) {\n        return policy.createHTML(data);\n    } else {\n        return data;\n    }\n}\n\nexport const getOwnPropertyDescriptors = function (object:any) {\n    if (Object.hasOwnProperty('getOwnPropertyDescriptors')) {\n        return Reflect.get(Object, 'getOwnPropertyDescriptors')(object);\n    } else {\n        return Reflect.ownKeys(object).reduce((descriptors, key) => {\n            return Object.defineProperty(descriptors, key, {\n                configurable: true,\n                enumerable: true,\n                writable: true,\n                value: Object.getOwnPropertyDescriptor(object, key)\n            });\n        });\n    }\n}", "import { createHTML } from './poly';\n// import parse from './parse';\n\nexport const HtmlCache = new WeakMap();\nexport const HtmlSymbol = Symbol('html');\n\ntype TemplateExpressionsArray = any[];\n\n// export class H {\n//     strings:TemplateStringsArray;\n//     expressions:TemplateExpressionsArray;\n//     template: HTMLTemplateElement;\n//     constructor(strings: TemplateStringsArray, expressions: TemplateExpressionsArray, template: HTMLTemplateElement) {\n//         this.strings = strings;\n//         this.expressions = expressions;\n//         this.template = template;\n//     }\n// }\n\nexport default function html(strings: TemplateStringsArray, ...expressions: TemplateExpressionsArray) {\n    if (HtmlCache.has(strings)) {\n        const template = HtmlCache.get(strings);\n        // return new H(strings, expressions, template);\n        return { strings, expressions, values:expressions, template, symbol: HtmlSymbol };\n    } else {\n        let data = '';\n\n        const length = strings.length - 1;\n\n        for (let index = 0; index < length; index++) {\n            data += `${strings[index]}{{${index}}}`;\n        }\n\n        data += strings[length];\n\n        const template = document.createElement('template');\n        template.innerHTML = createHTML(data);\n\n        // const template = parse(data);\n\n        HtmlCache.set(strings, template);\n\n        // return new H(strings, expressions, template);\n        return { strings, expressions, values:expressions, template, symbol: HtmlSymbol };\n    }\n}\n", "export default function display(data: any): string {\n    switch (typeof data) {\n        case 'undefined':\n            return '';\n        case 'string':\n            return data;\n        case 'number':\n            return `${data}`;\n        case 'bigint':\n            return `${data}`;\n        case 'boolean':\n            return `${data}`;\n        case 'function':\n            return `${data()}`;\n        case 'symbol':\n            return String(data);\n        case 'object':\n            return JSON.stringify(data);\n        default:\n            throw new Error('display - type not handled');\n    }\n}\n", "export type ObserveValue = any;\nexport type ObserveTarget = any;\nexport type ObserveReceiver = any;\nexport type ObserveMethod = () => void;\nexport type ObserveKey = symbol | string;\nexport type ObserveData = Record<string, any>;\n\nconst ObserveCache = new WeakMap();\nconst ObserveNext = Promise.resolve();\n\nconst ObserveSet = function (method: ObserveMethod, target: ObserveTarget, key: ObserveKey, value: ObserveValue, receiver: ObserveReceiver) {\n    if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);\n\n    const from = Reflect.get(target, key, receiver);\n\n    if (from === value) return true;\n    if (Number.isNaN(from) && Number.isNaN(value)) return true;\n\n    if (from && (from.constructor.name === 'Object' || from.constructor.name === 'Array' || from.constructor.name === 'Function')) {\n        const cache = ObserveCache.get(from);\n        if (cache === value) return true;\n        ObserveCache.delete(from);\n    }\n\n    Reflect.set(target, key, value, receiver);\n\n    ObserveNext.then(method);\n\n    return true;\n};\n\nconst ObserveGet = function (method: ObserveMethod, target: ObserveTarget, key: ObserveKey, receiver: ObserveReceiver): ObserveValue {\n    if (typeof key === 'symbol') return Reflect.get(target, key, receiver);\n\n    const value = Reflect.get(target, key, receiver);\n\n    if (value && (value.constructor.name === 'Object' || value.constructor.name === 'Array')) {\n        const cache = ObserveCache.get(value);\n        if (cache) return cache;\n\n        const proxy = new Proxy(value, {\n            get: ObserveGet.bind(null, method),\n            set: ObserveSet.bind(null, method),\n            deleteProperty: ObserveDelete.bind(null, method),\n        });\n\n        ObserveCache.set(value, proxy);\n        return proxy;\n    }\n\n    if (value && target.constructor.name === 'Object' && (value.constructor.name === 'Function' || value.constructor.name === 'AsyncFunction')) {\n        const cache = ObserveCache.get(value);\n        if (cache) return cache;\n\n        const proxy = new Proxy(value, {\n            apply(t, _, a) {\n                return Reflect.apply(t, receiver, a);\n            },\n        });\n\n        ObserveCache.set(value, proxy);\n        return proxy;\n    }\n\n    return value;\n};\n\nconst ObserveDelete = function (method: ObserveMethod, target: ObserveTarget, key: ObserveKey) {\n    if (typeof key === 'symbol') return Reflect.deleteProperty(target, key);\n\n    const from = Reflect.get(target, key);\n    ObserveCache.delete(from);\n    Reflect.deleteProperty(target, key);\n\n    ObserveNext.then(method);\n\n    return true;\n};\n\nconst Observe = function (data: ObserveData, method: ObserveMethod) {\n    return new Proxy(data, {\n        get: ObserveGet.bind(null, method),\n        set: ObserveSet.bind(null, method),\n        deleteProperty: ObserveDelete.bind(null, method),\n    });\n};\n\nexport default Observe;\n", "const booleans = [\n    'allowfullscreen',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'compact',\n    'controls',\n    'declare',\n    'default',\n    'defaultchecked',\n    'defaultmuted',\n    'defaultselected',\n    'defer',\n    'disabled',\n    'draggable',\n    'enabled',\n    'formnovalidate',\n    'indeterminate',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nohref',\n    'noshade',\n    'hidden',\n    'novalidate',\n    'nowrap',\n    'open',\n    'pauseonexit',\n    'readonly',\n    'required',\n    'reversed',\n    'scoped',\n    'seamless',\n    'selected',\n    'sortable',\n    'spellcheck',\n    'translate',\n    'truespeed',\n    'typemustmatch',\n    'visible',\n];\n\nexport default booleans;\n", "import html from './html';\nimport display from './display';\nimport observe from './observe';\nimport booleans from './booleans';\nimport { HtmlSymbol } from './html';\nimport { includes, replaceChildren } from './poly';\n\ntype Value = any;\ntype OldValue = Value;\ntype NewValue = Value;\ntype Values = Array<Value>;\ntype Actions = Array<(oldValue: OldValue, newValue: NewValue) => void>;\n\nconst links= [ 'src', 'href', 'xlink:href' ];\nconst safePattern = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i;\n// const dangerousPattern = /j\\s*a\\s*v\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*:|d\\s*a\\s*t\\s*a\\s*:\\s*t\\s*e\\s*x\\s*t\\s*\\/\\s*h\\s*t\\s*m\\s*l/i;\nconst dangerousLink = function (data: string) {\n    return typeof data !== 'string' || !safePattern.test(data);\n    // return typeof data !== 'string' || !safePattern.test(data) || dangerousPattern.test(data);\n};\n\nconst RootCache = new WeakMap();\n\nconst ObjectAction = function (start: Text, end: Text, actions: Actions, oldValue: OldValue, newValue: NewValue) {\n    oldValue = oldValue ?? {};\n    newValue = newValue ?? {};\n\n    if (oldValue?.strings !== newValue.strings) {\n        let next;\n        let node = end.previousSibling;\n        while (node !== start) {\n            next = node?.previousSibling as ChildNode;\n            node?.parentNode?.removeChild(node);\n            node = next;\n        }\n\n        // const fragment = document.importNode(newValue.template.content, true);\n        // RenderWalk(fragment, newValue.values, actions);\n\n        const fragment = newValue.template.content.cloneNode(true);\n        RenderWalk(fragment, newValue.values, actions);\n        document.adoptNode(fragment);\n\n        const l = actions.length;\n        for (let i = 0; i < l; i++) {\n            actions[i](oldValue.values?.[i], newValue.values[i]);\n        }\n\n        end.parentNode?.insertBefore(fragment, end);\n    } else {\n        const l = actions.length;\n        for (let i = 0; i < l; i++) {\n            actions[i](oldValue.values?.[i], newValue.values[i]);\n        }\n    }\n};\n\nconst ArrayAction = function (start: Text, end: Text, actions: Actions, oldValue: OldValue, newValue: NewValue) {\n    oldValue = oldValue ?? [];\n    newValue = newValue ?? [];\n\n    const oldLength = oldValue.length;\n    const newLength = newValue.length;\n    const common = Math.min(oldLength, newLength);\n\n    for (let i = 0; i < common; i++) {\n        actions[i](oldValue[i], newValue[i]);\n    }\n\n    if (oldLength < newLength) {\n        const template = document.createElement('template');\n        for (let i = oldLength; i < newLength; i++) {\n            if (newValue[i]?.constructor === Object && newValue[i]?.symbol === HtmlSymbol) {\n                const start = document.createTextNode('');\n                const end = document.createTextNode('');\n                const action = ObjectAction.bind(null, start, end, []);\n                template.content.appendChild(start);\n                template.content.appendChild(end);\n                actions.push(action);\n                action(oldValue[i], newValue[i]);\n            } else {\n                const node = document.createTextNode('');\n                const action = StandardAction.bind(null, node as Text);\n                template.content.appendChild(node);\n                actions.push(action);\n                action(oldValue[i], newValue[i]);\n            }\n        }\n        end.parentNode?.insertBefore(template.content as Node, end);\n    } else if (oldLength > newLength) {\n        for (let i = oldLength-1; i > newLength-1; i--) {\n            if (oldValue[i]?.constructor === Object && oldValue[i]?.symbol === HtmlSymbol) {\n                const { template } = oldValue[i];\n                let removes = template.content.childNodes.length + 2;\n                while (removes--) end.parentNode?.removeChild(end.previousSibling as Node);\n            } else {\n                end.parentNode?.removeChild(end.previousSibling as Node);\n            }\n        }\n        actions.length = newLength;\n    }\n};\n\nconst StandardAction = function (node: Text, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    node.textContent = newValue;\n};\n\nconst AttributeOn = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    if (typeof oldValue === 'function') element.removeEventListener(attribute.name.slice(2), oldValue);\n    if (typeof newValue !== 'function') return console.warn(`XElement - attribute name \"${attribute.name}\" and value \"${newValue}\" not allowed`);\n    element.addEventListener(attribute.name.slice(2), newValue);\n};\n\nconst AttributeBoolean = function (element: Element, attribute: { name: string; value: any }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n\n    const value = newValue ? true : false;\n    if (value) element.setAttribute(attribute.name, '');\n    else element.removeAttribute(attribute.name);\n\n    attribute.value = value;\n    Reflect.set(element, attribute.name, attribute.value);\n};\n\nconst AttributeValue = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    const value = display(newValue);\n    attribute.value = value;\n    Reflect.set(element, attribute.name, attribute.value);\n    element.setAttribute(attribute.name, attribute.value);\n};\n\nconst AttributeLink = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n\n    if (dangerousLink(newValue)) {\n        element.removeAttribute(attribute.name);\n        console.warn(`XElement - attribute name \"${attribute.name}\" and value \"${newValue}\" not allowed`);\n        return;\n    }\n\n    attribute.value = newValue;\n    Reflect.set(element, attribute.name, attribute.value);\n    element.setAttribute(attribute.name, attribute.value);\n};\n\nconst AttributeStandard = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    attribute.value = newValue;\n    Reflect.set(element, attribute.name, attribute.value);\n    element.setAttribute(attribute.name, attribute.value);\n};\n\nconst AttributeName = function (element: Element, attribute: { name: string; value: string }, oldValue: OldValue, newValue: NewValue) {\n    if (oldValue === newValue) return;\n    element.removeAttribute(oldValue);\n\n    const name = newValue?.toLowerCase();\n\n    if (name === 'value') {\n        attribute.name = name;\n        AttributeValue(element, attribute, attribute.value, attribute.value);\n    } else if (name.startsWith('on')) {\n        console.warn(`XElement - dynamic attribute name \"${newValue}\" not allowed`);\n    } else if (includes(links, name)) {\n        console.warn(`XElement - dynamic attribute name \"${newValue}\" not allowed`);\n    } else if (includes(booleans, name)) {\n        attribute.name = name;\n        AttributeBoolean(element, attribute, attribute.value, attribute.value);\n    } else {\n        attribute.name = name;\n        AttributeStandard(element, attribute, attribute.value, attribute.value);\n    }\n\n    // if (\n    //     typeof newValue !== 'string' ||\n    //     newValue.startsWith('on') ||\n    //     links.includes(newValue)\n    // ) return console.warn(`XElement - dynamic attribute name \"${newValue}\" not allowed`);\n\n    // attribute.name = newValue;\n    // element.setAttribute(attribute.name, attribute.value);\n};\n\nexport const RenderWalk = function (fragment: DocumentFragment, values: Values, actions: Actions) {\n    const walker = document.createTreeWalker(document, 5, null);\n\n    walker.currentNode = fragment;\n\n    let index = 0;\n    let node: Node | null = fragment.firstChild;\n\n    while ((node = walker.nextNode()) !== null) {\n        if (node.nodeType === Node.TEXT_NODE) {\n\n            const start = node.nodeValue?.indexOf('{{') ?? -1;\n\n            if (start == -1) continue;\n\n            if (start != 0) {\n                (node as Text).splitText(start);\n                node = walker.nextNode() as Node;\n            }\n\n            const end = node.nodeValue?.indexOf('}}') ?? -1;\n\n            if (end == -1) continue;\n\n            if (end + 2 != node.nodeValue?.length) {\n                (node as Text).splitText(end + 2);\n            }\n\n            const newValue = values[index++];\n\n            if (newValue?.constructor === Object && newValue?.symbol === HtmlSymbol) {\n                const start = document.createTextNode('');\n                const end = node;\n                end.nodeValue = '';\n                end.parentNode?.insertBefore(start, end);\n                actions.push(ObjectAction.bind(null, start as Text, end as Text, []));\n            } else if (newValue?.constructor === Array) {\n                const start = document.createTextNode('');\n                const end = node;\n                end.nodeValue = '';\n                end.parentNode?.insertBefore(start, end);\n                actions.push(ArrayAction.bind(null, start as Text, end as Text, []));\n            } else {\n                (node as Text).textContent = '';\n                actions.push(StandardAction.bind(null, node as Text));\n            }\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\n            const names = (node as Element).getAttributeNames();\n            for (const name of names) {\n                const value = (node as Element).getAttribute(name) ?? '';\n                const attribute = { name, value };\n\n                const dynamicName = name.includes('{{') && name.includes('}}');\n                const dynamicValue = value.includes('{{') && value.includes('}}');\n\n                if (dynamicName) {\n                    index++;\n                    (node as Element).removeAttribute(name);\n                    actions.push(\n                        AttributeName.bind(null, node as Element, attribute),\n                    );\n                }\n\n                if (dynamicValue) {\n                    index++;\n                    (node as Element).removeAttribute(name);\n                    if (name === 'value') {\n                        actions.push(\n                            AttributeValue.bind(null, node as Element, attribute),\n                        );\n                    } else if (name.startsWith('on')) {\n                        actions.push(\n                            AttributeOn.bind(null, node as Element, attribute),\n                        );\n                    } else if (includes(links, name)) {\n                        actions.push(\n                            AttributeLink.bind(null, node as Element, attribute),\n                        );\n                    } else if (includes(booleans, name)) {\n                        actions.push(\n                            AttributeBoolean.bind(null, node as Element, attribute),\n                        );\n                    } else {\n                        actions.push(\n                            AttributeStandard.bind(null, node as Element, attribute),\n                        );\n                    }\n                }\n\n                if (!dynamicName && !dynamicValue) {\n                    if (includes(links, name)) {\n                        if (dangerousLink(value)) {\n                            (node as Element).removeAttribute(name);\n                            console.warn(`XElement - attribute name \"${name}\" and value \"${value}\" not allowed`);\n                        }\n                    } else if (name.startsWith('on')) {\n                        (node as Element).removeAttribute(name);\n                        console.warn(`XElement - attribute name \"${name}\" not allowed`);\n                    }\n                }\n\n            }\n        } else {\n            console.warn('node type not handled ', node.nodeType);\n        }\n    }\n};\n\nconst sleep = (time: number) => new Promise((resolve) => setTimeout(resolve, time ?? 0));\n\nconst render = async function (\n        root: Element | ShadowRoot,\n        // context: () => Record<any,any>,\n        // content: (context: Record<any,any>) => any\n        context: any,\n        content: any\n    ) {\n    const instance: any = {};\n\n    const update = async function () {\n        if (instance.busy) return;\n        else instance.busy = true;\n\n        await sleep(50);\n\n        if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n        const { values } = content(html, context);\n\n        const length = instance.actions.length;\n        for (let index = 0; index < length; index++) {\n            instance.actions[index](instance.values[index], values[index]);\n        }\n\n        instance.values = values;\n\n        if (context.upgraded) await context.upgraded()?.catch(console.error);\n\n        instance.busy = false;\n    };\n\n    const cache = RootCache.get(root);\n    if (cache && cache.disconnect) await cache.disconnect()?.catch?.(console.error);\n    if (cache && cache.disconnected) await cache.disconnected()?.catch(console.error);\n\n    context = observe(context(html), update);\n\n    RootCache.set(root, context);\n\n    if (context.connect) await context.connect()?.catch?.(console.error);\n    if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n    const { strings, values, template } = content(html, context);\n\n    instance.busy = false;\n    instance.actions = [];\n    instance.values = values;\n    instance.strings = strings;\n    instance.template = template;\n    // instance.fragment = document.importNode(template.content, true);\n    instance.fragment = template.content.cloneNode(true);\n\n    RenderWalk(instance.fragment, instance.values, instance.actions);\n\n    document.adoptNode(instance.fragment);\n\n    const length = instance.actions.length;\n    for (let index = 0; index < length; index++) {\n        instance.actions[index](undefined, values[index]);\n    }\n\n    if (root.replaceChildren) {\n        root.replaceChildren(instance.fragment);\n    } else {\n        replaceChildren(root, instance.fragment);\n    }\n\n    if (context.upgraded) await context.upgraded()?.catch(console.error);\n    if (context.connected) await context.connected()?.catch(console.error);\n};\n\nexport default render;\n", "// import Context from './context';\nimport Schedule from './schedule';\n// import Patch from './patch';\nimport Dash from './dash';\n// import render from './render';\nimport html from './html';\nimport observe from './observe';\nimport { getOwnPropertyDescriptors, replaceChildren } from './poly';\nimport { RenderWalk } from './render';\n\n// const DEFINED = new WeakSet();\n// const CE = window.customElements;\n// Object.defineProperty(window, 'customElements', {\n//     get: () => ({\n//         define(name: string, constructor: CustomElementConstructor, options?: ElementDefinitionOptions) {\n//             if (constructor.prototype instanceof Component && !DEFINED.has(constructor)) {\n//                 constructor = new Proxy(constructor, {\n//                     construct(target, args, extender) {\n//                         const instance = Reflect.construct(target, args, extender);\n//                         instance[upgrade]();\n//                         return instance;\n//                     },\n//                 });\n\n//                 DEFINED.add(constructor);\n//             }\n//             CE.define(name, constructor, options);\n//         },\n//         get: CE.get,\n//         whenDefined: CE.whenDefined,\n//     }),\n// });\n\n\n    // static slottedEvent = new Event('slotted');\n    // static slottingEvent = new Event('slotting');\n\n    // static adoptedEvent = new Event('adopted');\n    // static adoptingEvent = new Event('adopting');\n\n    // static updatedEvent = new Event('updated');\n    // static updatingEvent = new Event('updating');\n\n    // static upgradedEvent = new Event('upgraded');\n    // static upgradingEvent = new Event('upgrading');\n\n    // static connectedEvent = new Event('connected');\n    // static connectingEvent = new Event('connecting');\n\n    // static attributedEvent = new Event('attributed');\n    // static attributingEvent = new Event('attributing');\n\n    // static disconnectedEvent = new Event('disconnected');\n    // static disconnectingEvent = new Event('disconnecting');\n\n    // slotted?: ()=>Promise<void> | void;\n    // connecting?: ()=>Promise<void> | void;\n    // connected?: ()=>Promise<void> | void;\n    // attributed?: (name: string, from: string, to: string)=>Promise<void> | void;\n    // adopted?: ()=>Promise<void> | void;\n    // disconnected?: ()=>Promise<void> | void;\n\n    // async slottedCallback() {\n    //     this.dispatchEvent(XElement.slottingEvent);\n    //     await this.slotted?.();\n    //     this.dispatchEvent(XElement.slottedEvent);\n    // }\n\n    // async connectedCallback() {\n    //     this.dispatchEvent(XElement.connectingEvent);\n    //     await this.connecting?.();\n    //     this.#render();\n    //     // this[MOUNT](this[ROOT], this.#context, this.#template);\n\n    //     // const constructor = this.constructor as typeof XElement;\n    //     // this[MOUNT](this[ROOT], constructor.context, constructor.template);\n    //     await this.connected?.();\n    //     this.dispatchEvent(XElement.connectedEvent);\n    // }\n\n    // async disconnectedCallback() {\n    //     this.dispatchEvent(XElement.disconnectingEvent);\n    //     await this.disconnected?.();\n    //     this.dispatchEvent(XElement.disconnectedEvent);\n    // }\n\n    // async adoptedCallback() {\n    //     this.dispatchEvent(XElement.adoptingEvent);\n    //     await this.adopted?.();\n    //     this.dispatchEvent(XElement.adoptedEvent);\n    // }\n\n    // async attributeChangedCallback(name: string, from: string, to: string) {\n    //     this.dispatchEvent(XElement.attributingEvent);\n    //     await this.attributed?.(name, from, to);\n    //     this.dispatchEvent(XElement.attributedEvent);\n    // }\n\n\nexport const ROOT = Symbol('root');\nexport const MOUNT = Symbol('mount');\nexport const UPDATE = Symbol('update');\n\nexport const BUSY = Symbol('busy');\nexport const ACTIONS = Symbol('actions');\nexport const FRAGMENT = Symbol('fragment');\nexport const EXPRESSIONS = Symbol('expressions');\n\nconst create = function (this:any) {\n    const tag = this.tag ?? Dash(this.name);\n\n    if (!customElements.get(tag)) {\n        customElements.define(tag, this);\n    }\n\n    const element = document.createElement(tag) as any;\n    element[MOUNT]();\n\n    return element;\n};\n\nconst define = function (this:any) {\n    const tag = this.tag ?? Dash(this.name);\n    if (!customElements.get(tag)) return;\n    customElements.define(tag, this);\n};\n\nconst defined = function (this:any) {\n    const tag = this.tag ?? Dash(this.name);\n    return customElements.whenDefined(tag);\n};\n\nconst update = async function (this:any) {\n    if (this[BUSY]) return;\n    else this[BUSY] = true;\n\n    // await sleep(50);\n\n    // if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n    const { values } = this.template();\n    // const { values } = this.template(this.#c);\n    // const { values } = this.#template.call(this.#c, this.#c);\n    const expressions = values;\n\n    const length = this[ACTIONS].length;\n    for (let index = 0; index < length; index++) {\n        this[ACTIONS][index](this[EXPRESSIONS][index], expressions[index]);\n    }\n\n    this[EXPRESSIONS] = expressions;\n\n    // if (context.upgraded) await context.upgraded()?.catch(console.error);\n\n    // instance.busy = false;\n    this[BUSY] = false;\n};\n\nconst mount = async function (this:any) {\n    console.log(this)\n    // const instance: any = {};\n\n    // const cache = RootCache.get(root);\n    // if (cache && cache.disconnect) await cache.disconnect()?.catch?.(console.error);\n    // if (cache && cache.disconnected) await cache.disconnected()?.catch(console.error);\n\n    // this.#c = observe(this, ()=>this.#update());\n    // this.#c = observe(this, this.#update.bind(this));\n    // this.#c = observe(this.#context(), this.#update);\n\n    // RootCache.set(root, context);\n\n    // if (context.connect) await context.connect()?.catch?.(console.error);\n    // if (context.upgrade) await context.upgrade()?.catch?.(console.error);\n\n    const { values, template } = this.template();\n    // const { values, template } = this.#template(this.#c);\n    // const { values, template } = this.#template.call(this.#c, this.#c);\n    // this.#t = template;\n    this[EXPRESSIONS] = values;\n\n    this[FRAGMENT] = template.content.cloneNode(true) as DocumentFragment;\n\n    RenderWalk(this[FRAGMENT], this[EXPRESSIONS], this[ACTIONS]);\n\n    document.adoptNode(this[FRAGMENT]);\n\n    const length = this[ACTIONS].length;\n    for (let index = 0; index < length; index++) {\n        this[ACTIONS][index](undefined, this[EXPRESSIONS][index]);\n    }\n\n    if (this[ROOT].replaceChildren) {\n        this[ROOT].replaceChildren(this[FRAGMENT]);\n    } else {\n        replaceChildren(this[ROOT], this[FRAGMENT]);\n    }\n\n    // if (context.upgraded) await context.upgraded()?.catch(console.error);\n    // if (context.connected) await context.connected()?.catch(console.error);\n};\n\nexport default function component (Class:any) {\n\n    Class.create = create;\n    Class.define = define;\n    Class.defined = defined;\n    Class.tag = Class.tag || Dash(Class.name);\n\n    Object.defineProperties(Class.prototype, {\n        [UPDATE]: {\n            value: update,\n            writable: false,\n            enumerable: false,\n            configurable: false,\n        },\n        [MOUNT]: {\n            value: mount,\n            writable: false,\n            enumerable: false,\n            configurable: false,\n       }\n    });\n\n    const proxy =  new Proxy(Class, {\n        construct(target, args, extender) {\n            const self = Reflect.construct(target, args, extender) as any;\n\n            Object.defineProperties(self, {\n                [BUSY]: {\n                    value: false,\n                    writable: true,\n                    enumerable: false,\n                    configurable: false,\n                },\n                [ACTIONS]: {\n                    value: [],\n                    writable: true,\n                    enumerable: false,\n                    configurable: false,\n                },\n                [EXPRESSIONS]: {\n                    value: [],\n                    writable: true,\n                    enumerable: false,\n                    configurable: false,\n                },\n                [FRAGMENT]: {\n                    value: undefined,\n                    writable: true,\n                    enumerable: false,\n                    configurable: false,\n                },\n                [ROOT]: {\n                    value: target.shadow === true ? self.shadowRoot ?? self.attachShadow({ mode: 'open' }) : self,\n                    writable: true,\n                    enumerable: false,\n                    configurable: false,\n                },\n            });\n\n            const prototype = Object.getPrototypeOf(self);\n            const properties = target.observedProperties ?\n                target.observedProperties ?? [] :\n                [ ...Object.getOwnPropertyNames(self),\n                    ...Object.getOwnPropertyNames(prototype) ];\n\n            for (const property of properties) {\n\n                if (\n                    'attributeChangedCallback' === property ||\n                    'disconnectedCallback' === property ||\n                    'connectedCallback' === property ||\n                    'adoptedCallback' === property ||\n                    'constructor' === property ||\n                    'template' === property\n                ) continue;\n\n                const descriptor = Object.getOwnPropertyDescriptor(self, property) ?? Object.getOwnPropertyDescriptor(prototype, property);\n\n                if (!descriptor) continue;\n                if (!descriptor.configurable) continue;\n\n                Object.defineProperty(self, `_${property}`, {\n                    ...descriptor,\n                    enumerable: false\n                });\n\n                Object.defineProperty(self, property, {\n                    enumerable: descriptor.enumerable,\n                    configurable: descriptor.configurable,\n                    get: () => self[ `_${property}` ],\n                    set: (value) => {\n                        const result = self[ `_${property}` ] = value;\n                        self[UPDATE]();\n                        return result;\n                    }\n                });\n\n            }\n\n            console.log(Object.getOwnPropertyNames(self));\n            console.log(getOwnPropertyDescriptors(self));\n\n            customElements.upgrade(self);\n            customElements.whenDefined(Class.tag).then(()=> self[MOUNT]());\n            // setTimeout(()=> self[MOUNT]());\n            // self[MOUNT]();\n\n            return self;\n        }\n    });\n\n    // if (!customElements.get(Class.tag)) {\n    //     customElements.define(Class.tag, proxy);\n    // }\n\n    return proxy;\n}\n\n\nclass XTest extends HTMLElement {\n    // static tag = 'x-test';\n    // static shadow = true;\n    // static observedProperties = ['message'];\n\n    message = 'hello world';\n\n    // #message = 'hello world';\n    // get message (){return this.#message};\n    // set message (value){ this.#message=value};\n\n    template = () => html`\n        <h1>${this.message}</h1>\n        <input value=${this.message} oninput=${(e:any)=>this.message=e.target.value} />\n    `;\n}\n\ncomponent(XTest);\n\n// XTest = ;\n\n// const xtest = new XTest();\n// XTest.define();\n\n// const e = XTest.create();\n// console.log(e);\n// document.body.append(e);\n\n// customElements.define('x-test', component(XTest));\nconst e = document.createElement('x-test');\n// (e as any)[MOUNT]();\nsetTimeout(()=>{\nconsole.log(e.outerHTML)\ndocument.body.append(e);\n},2000);\n", "let busy = false;\n\nconst sleep = () => new Promise((resolve) => setTimeout(resolve, 0));\n\nconst Actions: any = [];\nconst OldValues: any = [];\nconst NewValues: any = [];\n\nexport default async function schedule(actions: any[], oldValues: any[], newValues: any[]) {\n    actions = actions ?? [];\n    oldValues = oldValues ?? [];\n    newValues = newValues ?? [];\n\n    Actions.push(...actions);\n    OldValues.push(...oldValues);\n    NewValues.push(...newValues);\n\n    if (busy) return;\n    busy = true;\n\n    let action;\n    let oldValue;\n    let newValue;\n    let max = performance.now() + 50;\n\n    while (Actions.length > 0) {\n        if (\n            (navigator as any).scheduling?.isInputPending() ||\n            performance.now() >= max\n        ) {\n            await sleep();\n            max = performance.now() + 50;\n            continue;\n        }\n\n        action = Actions.shift();\n        oldValue = OldValues.shift();\n        newValue = NewValues.shift();\n\n        if (oldValue !== newValue) {\n            await action(oldValue, newValue);\n        }\n    }\n\n    busy = false;\n}\n", "export default function define(name: string, constructor: CustomElementConstructor) {\n    customElements.define(name, constructor);\n}\n", "import render from './render';\n\ntype Route = {\n    path?: string;\n\n    render?: any;\n    context?: any;\n    content?: any;\n    construct?: any;\n\n    name?: string;\n    root: Element;\n};\n\nconst alls: Array<Route> = [];\nconst routes: Array<Route> = [];\n\nconst transition = async function (route: Route) {\n    // if (route.cache && route.instance) {\n    //     if (route.instance instanceof Component || route.instance.prototype instanceof Component) {\n    //         route.root.replaceChildren(route.instance);\n    //         await route.instance[$].render();\n    //     } else {\n    //         await route.instance.render();\n    //     }\n    // }\n\n    // if (route.component instanceof Component || route.component.prototype instanceof Component) {\n    //     route.name = route.name ?? Dash(route.component.name);\n\n    //     if (!/^\\w+-\\w+/.test(route.name)) route.name = `x-${route.name}`;\n\n    //     if (!customElements.get(route.name)) customElements.define(route.name, route.component);\n    //     await customElements.whenDefined(route.name);\n\n    //     route.instance = document.createElement(route.name);\n    //     route.root.replaceChildren(route.instance);\n    //     route.instance[$].render();\n\n    // }\n    // if (route.render) {\n    //     route.render();\n    // } else {\n    // route.render = await mount(route.root, route.context, route.content);\n    // }\n    await render(route.root, route.context, route.content);\n};\n\nconst navigate = function (event?: any) {\n    if (event && 'canIntercept' in event && event.canIntercept === false) return;\n    if (event && 'canTransition' in event && event.canTransition === false) return;\n\n    const destination = new URL(event?.destination.url ?? location.href);\n    const base = new URL(document.querySelector('base')?.href ?? location.origin);\n\n    base.hash = '';\n    base.search = '';\n    destination.hash = '';\n    destination.search = '';\n\n    const pathname = destination.href.replace(base.href, '/');\n    const transitions: Array<Route> = [];\n\n    for (const route of routes) {\n        if (route.path !== pathname) continue;\n        if (!route.root) continue;\n\n        // const current = Reflect.get(route.root, 'xRouterCurrent');\n        // if (current === route) continue;\n\n        // const busy = Reflect.get(route.root, 'xRouterBusy');\n        // if (busy) continue;\n\n        // if (Reflect.get(route.root, 'xRouterPath') === route.path) continue;\n\n        // const current = Reflect.get(route.root, 'xRouterCurrent');\n        // if (current) current.instance.childNodes = Array.from(current.root.childNodes);\n\n        // Reflect.set(route.root, 'xRouterBusy', true);\n        Reflect.set(route.root, 'xRouterPath', route.path);\n        transitions.push(route);\n    }\n\n    for (const all of alls) {\n        if (!all.root) continue;\n        let has = false;\n\n        for (const transition of transitions) {\n            if (transition.root === all.root) {\n                has = true;\n                break;\n            }\n        }\n\n        if (has) continue;\n        if (Reflect.get(all.root, 'xRouterPath') === pathname) continue;\n        // if (all.root && Reflect.get(all.root, 'xRouterBusy')) continue;\n        // if (all.root) Reflect.set(all.root, 'xRouterBusy', true);\n\n        transitions.push(all);\n    }\n\n    // if (!transitions.length) return;\n\n    if (event?.intercept) {\n        return event.intercept({ handler: () => transitions.map((route) => transition(route)) });\n    } else if (event?.transitionWhile) {\n        return event.transitionWhile(transitions.map((route) => transition(route)));\n    } else {\n        transitions.map((route) => transition(route));\n    }\n};\n\nconst router = function (path: string, root: Element, context: any, content: any) {\n    if (!path) throw new Error('XElement - router path required');\n    if (!root) throw new Error('XElement - router root required');\n    if (!context) throw new Error('XElement - router context required');\n    if (!content) throw new Error('XElement - router content required');\n\n    if (path === '/*') {\n        for (const all of alls) {\n            if (all.path === path && all.root === root) {\n                throw new Error('XElement - router duplicate path on root');\n            }\n        }\n\n        alls.push({ path, root, context, content });\n    } else {\n        for (const route of routes) {\n            if (route.path === path && route.root === root) {\n                throw new Error('XElement - router duplicate path on root');\n            }\n        }\n\n        routes.push({ path, root, context, content });\n    }\n\n    Reflect.get(window, 'navigation').addEventListener('navigate', navigate);\n};\n\nexport default router;\n", "import Component from './component';\nimport Schedule from './schedule';\n// import Context from './context';\nimport Define from './define';\nimport Router from './router';\nimport Render from './render';\n// import Patch from './patch';\n// import Mount from './mount';\n\nexport { Component };\nexport { Component as component };\n\nexport { Schedule };\nexport { Schedule as schedule };\n\n// export { Context };\n// export { Context as context };\n\nexport { Define };\nexport { Define as define };\n\nexport { Router };\nexport { Router as router };\n\nexport { Render };\nexport { Render as render };\n\n// export { Patch };\n// export { Patch as patch };\n\n// export { Mount };\n// export { Mount as mount };\n\nconst Index = {\n    Component,\n    Schedule,\n    // Context,\n    Define,\n    Router,\n    Render,\n    // Patch,\n    // Mount,\n    component: Component,\n    schedule: Schedule,\n    // context: Context,\n    define: Define,\n    router: Router,\n    render: Render,\n    // patch: Patch,\n    // mount: Mount,\n};\n\nexport default Index;\n"],
  "mappings": "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",
  "names": ["start", "end", "update", "values", "length", "e", "sleep", "define", "transition", "define"]
}
