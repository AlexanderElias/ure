<base href="/">
<title>Ideas</title>

<h1>Ideas</h1>

<x-c>

    <strong>Is Span:</strong>
    <span is="x-span" x-text="obj.text.toUpperCase()"></span>
    <br />

    <strong>Is Input:</strong>
    <input is="x-input" x-value="obj.text = event?.target?.value ?? obj.text" />
    <!-- <x-input x-value="obj.text = event?.target?.value ?? obj.text"></x-input> -->
    <br>

    <strong>X-T:</strong>
    <x-t>obj.text.toUpperCase()</x-t>
    <br>

    <strong>X-I:</strong>
    <x-i>obj.text = event?.target?.value ?? obj.text</x-i>
    </br>

</x-c>

<script type="module">

    // const i = document.createElement('input');
    // const t = document.createElement('template');
    // t.appendChild(i);
    // document.head.appendChild(t);
    // const inputComputedStyle = window.getComputedStyle(i);
    // const style = document.createElement('style');
    // let styleContent = '';
    // Array.from(inputComputedStyle).forEach(key => styleContent += `${key}: ${inputComputedStyle.getPropertyValue(key)} ${inputComputedStyle.getPropertyPriority(key)};`);
    // style.type = 'text/css';
    // style.innerHTML = `x-i { ${styleContent} }`;
    // document.head.appendChild(style);

    const proxies = new Map();
    const handlers = new Map();
    const meta = Symbol('meta');

    const change = async function ([references, reference, element]) {
        const nodes = references.get(reference) ?? references.set(reference, new Set()).get(reference);

        let iterator = nodes.values();
        let result = iterator.next();

        while (!result.done) {
            // if (element !== result.value) Promise.resolve(result.value).then(async element => element.render());
            Promise.resolve(result.value).then(async value => value?.render());
            result = iterator.next();
        }

    }

    const set = function (element, references, reference, target, key, value, receiver) {
        if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);

        const from = Reflect.get(target, key, receiver);
        // console.log('set:', reference, key, value, from, element);

        if (from === value) return true;
        if (Number.isNaN(from) && Number.isNaN(value)) return true;

        Reflect.set(target, key, value, receiver);

        reference = reference ? `${reference}.${key}` : key;
        if (references.has(reference)) references.get(reference).add(element);
        else references.set(reference, new Set([element]));
        // proxies?.get?.(element)?.remove?.(reference);

        Promise.resolve([references, reference, element]).then(change);

        return true;
    };

    const get = function (element, references, reference, target, key, receiver) {
        if (typeof key === 'symbol') return Reflect.get(target, key, receiver);
        // console.log('get:', reference, key, element);

        reference = reference ? `${reference}.${key}` : key;
        if (references.has(reference)) references.get(reference).add(element);
        else references.set(reference, new Set([element]));

        const value = Reflect.get(target, key, receiver);

        if (value && typeof value === 'object') {
            if (!proxies.has(element)) proxies.set(element, new Map());
            let proxy = proxies.get(element).get(reference);
            if (proxy) return proxy;
            proxy = new Proxy(value, { get: get.bind(null, element, references, reference), set: set.bind(null, element, references, reference) });
            proxies.get(element).set(reference, proxy);
            return proxy;
            // return new Proxy(value, { get: get.bind(null, element, references, reference), set: set.bind(null, element, references, reference) });
        }

        return value;
    };

    const context = function (data, element, references, reference) {
        return new Proxy(data, {
            get: get.bind(null, element, references, reference),
            set: set.bind(null, element, references, reference)
        });
    };

    const handler = function (code) {
        code = `with($context){return(${code});}`;
        return handlers.get(code) ?? handlers.set(code, new Function('$context', 'event', code)).get(code);
    };

    const render = async function (data, references, reference) {
        const self = this[meta];

        if (!self.rendered) {
            self.rendered = true;
            self.context = context(data, this, references, reference);

            const text = this.attributes['x-text'];
            if (text) self.text = handler(text.value);

            const html = this.attributes['x-html'];
            if (html) self.html = handler(html.value);

            const value = this.attributes['x-value'];
            if (value) {
                self.value = handler(value.value);
                this.addEventListener('input', async (event) => {
                    this.value = await self.value(self.context, event);
                });
            }

        }

        if (self.text) this.textContent = await self.text(self.context);
        if (self.html) this.innerHTML = await self.html(self.context);
        if (self.value) this.value = await self.value(self.context);
    };

    const instance = function () {
        return {
            rendered: false,
            html: undefined,
            text: undefined,
            value: undefined,
            context: undefined,
        }
    };

    class XT extends HTMLElement {
        #node;
        #text;
        #context;
        #rendered = false;
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.#node = this.childNodes[0];
        }
        async render(data, references, reference) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.#context = context(data, this, references, reference);
                this.#text = handler(this.#node.textContent);
            }

            this.#node.textContent = await this.#text(this.#context);
        }
    }
    customElements.define('x-t', XT);

    class XI extends HTMLElement {
        #handler;
        #context;
        #rendered = false;
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
                <style>
                    :host {
                        width: 10rem;
                        height: 1.2rem;
                        display: inline-block;
                        border: 1px solid lightgray;
                    }
                </style>
                <slot></slot>
            `;
            this.contentEditable = true;
        }
        #value = undefined;
        get value() {
            return this.#value;
        }
        set value(value) {
            this.setAttribute('value', this.textContent = this.#value = value);
        }
        async render(data, references, reference) {

            if (!this.#rendered) {
                this.#rendered = true;
                this.#context = context(data, this, references, reference);
                this.#handler = handler(this.textContent);
                this.addEventListener('input', this.input);
            }

            this.value = await this.#handler(this.#context);
        }
        async input(event) {
            this.value = this.textContent;
            this.value = await this.#handler(this.#context, event);
        }
    }
    customElements.define('x-i', XI);

    class XContext extends HTMLElement {
        references = new Map();
        // context = { obj: { text: 'Hello World' } };
        // context = new Proxy({ obj: { text: 'Hello World' } }, { get: get.bind(null, null, this.references, ''), set: set.bind(null, null, this.references, '') });
        context = context({ obj: { text: 'Hello World' } }, null, this.references, '');
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.shadowRoot.firstElementChild.addEventListener('slotchange', this.change.bind(this));
        }
        async each(element) {
            await element.render(this.context, this.references, '');
        }
        async change(event) {
            Promise.all(Array.prototype.map.call(this.querySelectorAll('x-i, x-t, [is^="x-"]'), this.each.bind(this)));
        }
    }
    customElements.define('x-c', XContext);

    class XSpan extends HTMLSpanElement {
        [meta] = instance();
        render = render;
    }
    customElements.define('x-span', XSpan, { extends: 'span' });

    class XInput extends HTMLInputElement {
        [meta] = instance();
        render = render;

    }
    customElements.define('x-input', XInput, { extends: 'input' });

</script>