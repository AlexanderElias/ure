<base href="/">
<title>Ideas</title>

<h1>Ideas</h1>

<x-context>

    <strong>Slotted Span:</strong>
    <span text="{{obj.text.toUpperCase()}}"></span>
    <br>

    <strong>Slotted Input:</strong>
    <input value="{{obj.text = event?.target?.value ?? obj.text}}">
    <br>

</x-context>

<script type="module">

    const x = Symbol('x');
    const proxies = new Map();
    const handlers = new Map();

    const all = function (promises) {
        return Promise.all(promises);
    };

    const map = function (item, method, self) {
        return Array.prototype.map.call(item, method, self);
    };

    const resolve = function (item, method) {
        return Promise.resolve(item).then(method);
    };

    const setted = async function ([references, reference, element]) {
        const nodes = references.get(reference) ?? references.set(reference, new Set()).get(reference);

        let iterator = nodes.values();
        let result = iterator.next();

        while (!result.done) {
            // if (element !== result.value) Promise.resolve(result.value).then(async element => element.render());
            resolve(result.value, async node => node?.[x]?.render());
            result = iterator.next();
        }

    };

    const set = function (element, references, reference, target, key, value, receiver) {
        if (typeof key === 'symbol') return Reflect.set(target, key, value, receiver);

        const from = Reflect.get(target, key, receiver);
        // console.log('set:', reference, key, value, from, element);

        if (from === value) return true;
        if (Number.isNaN(from) && Number.isNaN(value)) return true;

        Reflect.set(target, key, value, receiver);

        reference = reference ? `${reference}.${key}` : key;
        if (references.has(reference)) references.get(reference).add(element);
        else references.set(reference, new Set([element]));
        // proxies?.get?.(element)?.remove?.(reference);

        resolve([references, reference, element], setted);

        return true;
    };

    const get = function (element, references, reference, target, key, receiver) {
        if (typeof key === 'symbol') return Reflect.get(target, key, receiver);
        // console.log('get:', reference, key, element);

        reference = reference ? `${reference}.${key}` : key;
        if (references.has(reference)) references.get(reference).add(element);
        else references.set(reference, new Set([element]));

        const value = Reflect.get(target, key, receiver);

        if (value && typeof value === 'object') {
            if (!proxies.has(element)) proxies.set(element, new Map());
            let proxy = proxies.get(element).get(reference);
            if (proxy) return proxy;
            proxy = new Proxy(value, { get: get.bind(null, element, references, reference), set: set.bind(null, element, references, reference) });
            proxies.get(element).set(reference, proxy);
            return proxy;
            // return new Proxy(value, { get: get.bind(null, element, references, reference), set: set.bind(null, element, references, reference) });
        }

        return value;
    };

    const context = function (data, references, reference, node) {
        return new Proxy(data, {
            get: get.bind(null, node, references, reference),
            set: set.bind(null, node, references, reference)
        });
    };

    const handler = function (code) {
        code = `with($context){return(${code.slice(2, -2)});}`;
        return handlers.get(code) ?? handlers.set(code, new Function('$context', 'event', code)).get(code);
    };

    const binder = function (container, attribute) {

        attribute[x] = {
            node: attribute,
            name: attribute.name,
            value: attribute.value,
            owner: attribute.ownerElement,
            handler: handler(attribute.value),
            context: context(container.context, container.references, '', attribute)
        };

        if (attribute[x].name === 'value') {
            attribute[x].render = async function (event) {
                attribute[x].owner.value = await attribute[x].handler(attribute[x].context, event);
            };
            attribute[x].owner.addEventListener('input', attribute[x].render);
        } else if (attribute[x].name === 'text') {
            attribute[x].render = async function () {
                attribute[x].owner.textContent = await attribute[x].handler(attribute[x].context);
            };
        } else if (attribute[x].name === 'html') {
            attribute[x].render = async function () {
                attribute[x].owner.innerHTML = await attribute[x].handler(attribute[x].context);
            };
        }

        attribute[x].node.value = '';

        return attribute[x];
    };

    const bind = async function (element) {
        const renders = [];

        for (const attribute of element.attributes) {
            const { name, value } = attribute;
            if (value.startsWith('{{') && value.endsWith('}}')) {
                renders.push(binder(this, attribute));
            }
        }

        await all(map(renders, async (binder) => await (await binder).render()));
        await all(map(element.children, bind, this));
    };

    class XContext extends HTMLElement {

        references = new Map();
        context = context({}, this.references, '');

        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = '<slot></slot>';
            this.shadowRoot.addEventListener('slotchange', this.slotted.bind(this));

            // maybe handle element attributes here

            Object.assign(this.context, { obj: { text: 'Hello World' } });

            const template = document.createElement('template');
            template.innerHTML = '<strong>Shadow Span: </strong><span text="{{obj.text}}"></span><br>';

            this.shadowRoot.prepend(template.content);

            all(map(this.shadowRoot.children, bind, this));

        }

        async slotted(event) {
            console.log('slotted');
            // console.log(event);
            // console.log(event.target);
            const slot = event.target;
            const elements = slot.assignedElements();
            await all(map(elements, bind, this));
        }

        async connectedCallback() {
            console.log('connected');
        }

    }

    customElements.define('x-context', XContext);
</script>